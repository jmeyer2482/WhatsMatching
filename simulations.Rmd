---
title: "Untitled"
output: html_document
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(MatchIt)
library(cem)
library(ggpubr)
```




```{r}

#########################################################################
###############function to create data set
create.sim1.data <- function(){
  t = c(rep("C", 25),rep("T", 25),rep("C", 25),rep("T", 25),rep("C", 50))
  g = c(rep("Paired", 50), rep("Random", 50), rep("Controls", 50))
  
  px1c <- runif(25, min = -2, max = 2)
  px2c <- runif(25, min = -2, max = 2)
  px1t <- px1c + runif(25, min = -0.05, max = 0.05)
  px2t <- px2c + runif(25, min = -0.05, max = 0.05)
  
  rx1 <- runif(50, min = -2, max = 2)
  rx2 <- runif(50, min = -8, max = -4)
  
  cx1 <- runif(50, min = -6, max = -4)
  cx2 <- runif(50, min = -8, max = 2)
  
  x1 <- c(px1c, px1t, rx1, cx1)
  x2 <- c(px2c, px2t, rx2, cx2)
  
  data <- as.data.frame(list(x1=x1, x2=x2, t=t, g=g))

  return(data)
}


  
#########################################################################
################calculate the mahalanobis distance between each row and all others

mah.dist <- function(X, cov.m=cov(X)){  
  out <- sapply(1:nrow(X), function(i) {
    mahalanobis(x = X, 
                center = do.call("c", X[i, ]),
                cov = cov.m, tol = 1e-20)
  })
}

a <-  mah.dist(d2[1:2])
d2[1:2]

#########################################################################
###############function to return lowest pairwise assessments of mahalanobis distances
mah <- function(X, y, replace = TRUE) {
  
  #limit X to variables for matching
  # X <- x[,1:2]
  
  #matrix of mahalanobis distances
  d.m <- mah.dist(X)
  
  #remove irrelevant values from matrix 
  #(those where it matches control to control or treat to treat)
  
  y.uniq <- y %>% unique() 
  
  for (i in 1:length(y.uniq)){
    d.m[y==y.uniq[i], y==y.uniq[i]] <- NA
  }
  
  #return the "distance" to the closest point
  if (replace == TRUE) {
    return(apply(d.m, 1, FUN = min, na.rm=T))
  }
  
  if (replace == FALSE) {
    
      j=nrow(d.m)  
      d <- NULL
      
      for (i in 1:(nrow(d.m)/2)) {
        
        if (all(is.na(d.m))==FALSE) {
          t.i <- which(d.m==min(d.m, na.rm=T), arr.ind = TRUE)[1]
          c.i <- which(d.m==min(d.m, na.rm=T), arr.ind = TRUE)[2]
        
          v <- d.m[t.i,c.i]
          
          
          d.m[,c(t.i,c.i)] <- NA
          d.m[c(t.i,c.i),] <- NA
          
          } else {
          
            t.i <- setdiff(1:150, as.numeric(rownames(d)))[length(d)]
            c.i <- setdiff(1:150, as.numeric(rownames(d)))[length(d)]
            v = NA
        }
        
        d <- rbind(d, cbind(m.ord=j, m.dist=v, m.pair=c.i, m.ind=t.i))
        j <- j-1
    
        d <- rbind(d, cbind(m.ord=j, m.dist=v, m.pair=c.i, m.ind=c.i))
        j <- j-1 
      
      }
      
      return(d %>% as.data.frame())
    
  }
}

#########################################################################
###############function for generating propensity score
prop <- function(x, y, model = "glm", replace = TRUE){
  
  #generate probabilities
  if (model == "glm"){ p <- glm(y ~ ., data = x, family = "binomial") }
  if (model == "lm"){ p <- lm(y ~ ., data = x) }
  
  #matrix of probability distances
  d.m <- dist(p$fitted.values, upper = T) %>% as.matrix() %>% as.data.frame()
  
  #remove irrelevant values from matrix 
  #(those where it matches with itself or control to control or treat to treat)
  y.uniq <- y %>% unique() 
  
  for (i in 1:length(y.uniq)){
    d.m[y==y.uniq[i], y==y.uniq[i]] <- NA
  }
  
  #method with replacement
  if (replace == TRUE) {
      return(
        cbind(p.dist=apply(d.m, 1, FUN = min, na.rm=T), p.score=p$fitted.values) %>% 
                as.data.frame()
              )
  } 
  
  #method without replacement
  if (replace == FALSE) {
    
      j=nrow(d.m)  
      d <- NULL
      
      for (i in 1:(nrow(d.m)/2)) {
        
        if (all(is.na(d.m))==FALSE) {
          t.i <- which(d.m==min(d.m, na.rm=T), arr.ind = TRUE)[1]
          c.i <- which(d.m==min(d.m, na.rm=T), arr.ind = TRUE)[2]
        
          v <- d.m[t.i,c.i]
          
          
          d.m[,c(t.i,c.i)] <- NA
          d.m[c(t.i,c.i),] <- NA
          
          } else {
          
            t.i <- setdiff(1:150, as.numeric(rownames(d)))[length(d)]
            c.i <- setdiff(1:150, as.numeric(rownames(d)))[length(d)]
            v = NA
        }
        
        d <- rbind(d, cbind(p.ord=j, p.dist=v, p.pair=c.i, p.ind=t.i))
        j <- j-1
    
        d <- rbind(d, cbind(p.ord=j, p.dist=v, p.pair=c.i, p.ind=c.i))
        j <- j-1 
      
      }
      
      return(cbind(d,p.score=p$fitted.values) %>% as.data.frame())
    
  }
}
```




```{r}
#set random environment
set.seed(25)

#initialise data frame
data <- NULL

#build data
for (i in 1:200){
  dt <- create.sim1.data()
  m <- mah(dt[,1:2], dt$t)
  p <- prop(dt[,1:2], ifelse(dt$t=="C",0,1))
  a <- cbind(set=i, dt, m, p)
  
  a <- a %>% arrange(desc(m)) %>% mutate(m.order = row_number())
  a <- a %>% arrange(desc(p.dist)) %>% mutate(p.order = row_number())
  
    if (is.null(data)){
      data <- a
    } else {
      data <- rbind(a, data)
    }
  a <- NULL
}

p

# d$t %>% unique() %>% length()

# d[,1:2]

# data <- create.data()
# data <- cbind(data, m=mah(data))
# data <- data %>% arrange(desc(m)) %>% mutate(id = row_number())

# g <- data[data$set==1,2:3]
# 
# h <- ifelse(data$t[data$set==1]=="C",0,1)
# 
# glm(h ~ ., data = g, family = "binomial")
# glm(ifelse(t=="C",0,1) ~ x1 + x2, data = data[data$set==1,], family = "binomial")

```



```{r, fig.width=10, fig.height=7}
a <- ggplot(data=data, aes(x=m.order, y=set, color=g)) + geom_point(shape = 15, alpha = 0.8) +
  scale_color_manual(values = c("black", "blue", "red")) + 
  labs(title = "Mahalanobis", y = "Simulation #", x = "Number of Dropped Obs.") + theme(panel.background = element_rect(fill="white", color = "black"), legend.position = "none")

b <- ggplot(data=data, aes(x=p.order, y=set, color=g)) + geom_point(shape = 15, alpha = 0.8) +
  scale_color_manual(values = c("black", "blue", "red")) + 
  labs(title = "Propensity Score", y = "Simulation #", x = "Number of Dropped Obs.") + theme(panel.background = element_rect(fill="white", color = "black"), legend.position = "none")

c <- ggplot(data=data[data$set==1,], aes(x1, x2, color=g, label=t)) + geom_text(alpha=0.8) +
  scale_color_manual(values = c("black", "blue", "red")) + theme(panel.background = element_rect(fill="white", color = "black"), legend.position = "none") + scale_y_continuous(limits = c(-8, 2), breaks = seq(-8, 2, by = 2))

d <- ggarrange(c,a,b, widths = c(2,1,1), ncol = 3, legend = F)

rm(a,b,c)

print(d)

```


```{r}
ggplot(data = data, aes(p.score, fill = g)) + geom_histogram(alpha = 0.5, position = "identity", bins = 50)
ggplot(data = data, aes(m, fill = g)) + geom_histogram(alpha = 0.5, position = "identity", bins = 50)
ggplot(data = data, aes(p.dist, fill = g)) + geom_histogram(alpha = 0.5, position = "identity", bins = 50)

```




```{r}
#function to return lowest pairwise assessments of mahalanobis distances
# mah <- function(x, cx = NULL) {
  
  #limit X to variables for matching
  x <- create.sim1.data()

  X <- x[,1:2]
  
  #calculate the mahalanobis distance between rows
  cx <- cov(X)
  mah.out <- sapply(1:nrow(X), function(i) {
    mahalanobis(x = X, 
                center = do.call("c", X[i, ]),
                cov = cov(X))
  })
  
  d.m <- out 
  
  d.m[x$t=="C", x$t=="C"] <- NA
  d.m[x$t=="T", x$t=="T"] <- NA
  
  # d.m <- as.dist(d.m, upper = F)
  
#   class(d.m)  
#   nearest_neighbor_search(d.m, 1)
# 
# 
# setdiff(1:150, c(1:10,33,45,78))
# 
# d.m.ord <- order(d.m, decreasing = T, method = "shell") %>% matrix(ncol=150)
# d.m.ordr <- order(d.m, decreasing = T, method = "shell") %>% matrix(ncol=150, byrow = TRUE)
# 
# which.min(d.m) %>% arrayInd(which.min(d.m))
# which.min(d.m.ord)
# which.min(d.m.ordr)

# apply(d.m, 1, which.min)
# 
# d.m[arrayInd(which.min(d.m), dim(d.m))]
# 
# which(d.m==min(d.m, na.rm=T), arr.ind = T)
# 
# for (i in 1:(length(d.m)/2)) {
#   
#   r <- arrayInd(which.min(d.m), dim(d.m))[[1]]
#   c <- arrayInd(which.min(d.m), dim(d.m))[[2]]
#   
#   v <- d.m[arrayInd(which.min(d.m), dim(d.m))]
#   
#   d.m[,c(r,c)] <- NA
#   d.m[c(r,c),] <- NA
#   
#   }
#

get.min <- function(d.m) {
  
    if (all(is.na(d.m))==FALSE) {
      r <- arrayInd(which.min(d.m), dim(d.m))[[1]]
      c <- arrayInd(which.min(d.m), dim(d.m))[[2]]

      v <- d.m[r,c]

      d.m[,c(r,c)] <- NA
      d.m[c(r,c),] <- NA

      
      # } else {
      # 
      # r <- setdiff(1:nrow(d.m), as.numeric(rownames(d.m[])))[1]
      # c <- setdiff(1:ncol(d.m), as.numeric(rownames(d)))[2]
      # v = NA
    }

  d.m[,c(r,c)] <- NA
  d.m[c(r,c),] <- NA

  return(list(v,r,c, d.m))
}
  
```





```{r}
d.m <- out 
  
d.m[x$t=="C", x$t=="C"] <- NA
d.m[x$t=="T", x$t=="T"] <- NA
  

# get.min(d.m)[1:3]

values <- NULL
for (i in 1:(length(d.m)/2)) {
  
  if (all(is.na(d.m))==FALSE) {
  a <- get.min(d.m)
  
  d.m <- a[[4]]
  
  values <- rbind(values,
                  list(dist = a[[1]], ind = a[[2]], pair = a[[3]]), 
                  list(dist = a[[1]], ind = a[[3]], pair = a[[3]]) )
  }
}

values

```


```{r}
  #matrix of mahalanobis distances
  d.m <- as.dist(do.call("rbind", out), upper = T) %>% as.matrix() %>% as.data.frame()
  
  #remove irrelevant values from matrix 
  #(those where it matches with itself or control to control or treat to treat)
  # d.m[d.m==0] <- NA
  d.m[x$t=="C", x$t=="C"] <- NA
  d.m[x$t=="T", x$t=="T"] <- NA

  j=150  
  d <- NULL
  k = 1
  
  for (i in 1:(nrow(d.m)/2)) {
    
    if (all(is.na(d.m))==FALSE) {
      t.i <- which(d.m==min(d.m, na.rm=T), arr.ind = TRUE)[1]
      c.i <- which(d.m==min(d.m, na.rm=T), arr.ind = TRUE)[2]
    
      v <- d.m[t.i,c.i]
      
      
      d.m[,c(t.i,c.i)] <- NA
      d.m[c(t.i,c.i),] <- NA
      
      } else {
      
        t.i <- setdiff(1:150, as.numeric(rownames(d)))[1]
        c.i <- setdiff(1:150, as.numeric(rownames(d)))[2]
        v = NA
    }
    
    d <- rbind(d, cbind(x[t.i,], m.ord=j, m.dist=v, m.pair=t.i))
    j <- j-1

    d <- rbind(d, cbind(x[c.i,], m.ord=j, m.dist=v, m.pair=c.i))
    j <- j-1 
  
  }
  
  d <- cbind(d, t.num = ifelse(x$t=="C", 0, 1))
  
  p <- glm(t.num ~ x1 + x2, family = "binomial", data=d)
  
  d <- cbind(d, prop=p$fitted.values)
  
  ggplot(data=d) + geom_point(aes(x=ord, y=1, color=g), shape = 15, alpha = 0.8) +
  scale_color_manual(values = c("black", "blue", "red")) + 
  labs(title = "Mahalanobis", y = "Simulation #", x = "Number of Dropped Obs.") + theme(panel.background = element_rect(fill="white", color = "black"), legend.position = "none")

  
  # hist(d$mah.d, breaks = 100)
  hist(d$prop, breaks = 100)
```




```{r}
create.sim2.data <- function() {
    
    x1 <- c(runif(100, 0,5),runif(100, 1,6))
    x2 <- c(runif(100, 0,5),runif(100, 1,6))
    t <- c(rep("C",100),rep("T",100))
    t.num <- ifelse(t=="C",0,1)
    y <- 2*ifelse(t=="C",0,1) + x1 + x2 + rnorm(200)
    
    d <- list(x1=x1,x2=x2,t=t, t.num=t.num, y=y) %>% as.data.frame()
    
    return(d)
}

d2 <- create.sim2.data()

p <- prop(d2[c('x1','x2')], d2$t.num, replace = FALSE, model = "lm")# %>% arrange(p.ind)

#add ,mahalanobis distance
m <- mah(d2[c('x1','x2')], d2$t.num, replace = FALSE) %>% arrange(m.ind)

#add propensity score
d2 <- cbind(d2, ind=rownames(d2) %>% as.numeric())
d2 <- full_join(d2,m,by=c("ind"="m.ind"))
d2 <- full_join(d2,p, by=c("ind"="p.ind"))

b.labs <- c("Last 25 Matches","Third 25 Matches", "Second 25 Matches", "First 25 Matches")

d2$m.cuts <- cut(ceiling(d2$m.ord/2), breaks = 4, labels = b.labs)
d2$p.cuts <- cut(ceiling(d2$p.ord/2), breaks = 4, labels = b.labs)

a <- ggplot(d2, aes(x1,x2, color = t)) + 
  annotate("rect", xmin=0, xmax=5, ymin=0, ymax=5, alpha=0.1, fill="blue") + 
  annotate("rect", xmin=1, xmax=6, ymin=1, ymax=6, alpha=0.1, fill="red") +
  scale_color_manual(values=c("blue", "red")) +
  geom_line(aes(group = m.pair, alpha = m.cuts), color = "black") +
  scale_alpha_manual(values = c(.1,.3,.6,.9)) +#.8,.6,.4,.2)) +
  geom_point() + 
  theme_classic() 

b <- ggplot(d2, aes(x1,x2, color = t)) + 
  annotate("rect", xmin=0, xmax=5, ymin=0, ymax=5, alpha=0.1, fill="blue") + 
  annotate("rect", xmin=1, xmax=6, ymin=1, ymax=6, alpha=0.1, fill="red") +
  scale_color_manual(values=c("blue", "red")) +
  geom_line(aes(group = p.pair, alpha = p.cuts), color = "black") +
  scale_alpha_manual(values = c(.1,.3,.6,.9)) +#.8,.6,.4,.2)) +
  geom_point() + 
  theme_classic() 

ggarrange(a,b,common.legend = T)




# 
# rownames(d2)
# 
# d$p <- glm(t.num ~ x1 + x2, family = 'binomial', data = d)$fitted.values # prop(d) # %>% sort(decreasing = T) %>% names() %>% as.numeric()
# 
# #add stratification by propensity score into 5 groups
# #1 is lowest propensity score, 5 is the highest
# d <- d %>% arrange(p) %>% group_by(strat=(row_number()-1) %/% (n()/5) + 1) %>% mutate(strat = as.factor(strat))
# 
# #add weights
# d %>% mutate(t.num = ifelse(t=="C",0,1), wt = (t.num/p)+((1-t.num)/(1-p)))
# 
# 
# 
# pmax.int(x1)
```


```{r}

m.coef <- function(x, data=d2) {lm(x, data=data)$coefficients[[2]]} 
                                # return(coef(a)[2]) }

# m.l <- sapply(f, m.coef)



get.ests <- function(m, d, treat="t") {

    f <- paste(m$terms[[2]], m$terms[[1]], treat,
               c("", paste("+", attr(m$terms, "term.labels"))))
    
    ests <- sapply(f, m.coef, data = d)

  return(list(variance = var(ests), max.est = max(ests)))
}

get.ests(m,d2)

```




```{r}

start.time <- Sys.time()

m <- lm(y ~ x1 * x2 * I(x1*x2) * I(x1^2) * I(x2^2) * I(x1^2*x2) * I(x1*x2^2) * I(x1^3) * I(x2^3), data=d2)
# paste(m$terms[[3]], m$terms[[1]], attr(m$terms, "term.labels"))

# paste(m$terms[[2]], m$terms[[1]], "t", c("", paste("+", attr(m$terms, "term.labels"))))


all.est <- NULL

for (i in 1:2){
  
  d2 <- create.sim2.data()

  p.dt <- prop(d2[c('x1','x2')], d2$t.num, replace = FALSE, model = "glm")
  
  #add ,mahalanobis distance
  m.dt <- mah(d2[c('x1','x2')], d2$t.num, replace = FALSE)
  
  #add propensity score
  d2 <- cbind(d2, ind=rownames(d2) %>% as.numeric())
  d2 <- full_join(d2,m.dt,by=c("ind"="m.ind"))
  d2 <- full_join(d2,p.dt, by=c("ind"="p.ind"))
  
  m.estimates <- list(set = i, n = 0, get.ests(m,d2)) %>% as.data.frame()
  p.estimates <- list(set = i, n = 0, get.ests(m,d2)) %>% as.data.frame()
  
  for (j in 1:(nrow(d2)-5)){
    
    md.est <- d2 %>% subset(!m.ord %in% c(1:j))
    pd.est <- d2 %>% subset(!p.ord %in% c(1:j))
    
    m.estimates <- rbind(m.estimates, c(set = i, n=j, get.ests(m,md.est)))
    p.estimates <- rbind(p.estimates, c(set = i, n=j, get.ests(m,pd.est)))
    
  }
  
  all.est <- rbind(all.est, cbind(mah=m.estimates, prop=p.estimates))
  
}

time.taken <- round(Sys.time() - start.time,2)
time.taken

```


```{r}

ggplot(data=all.est) + 
  stat_summary(aes(x=mah.n, y=mah.variance), color = "blue", fun = "mean", geom = "line") +
  stat_summary(aes(x=prop.n, y=prop.variance), color = "red", fun = "mean", geom = "line")

```



```{r}
plot(all.est$n, all.est$variance, type = "l", col="blue", ylim = c(0,0.25))
lines(p.estimates$n, p.estimates$variance, col="red")

plot(all.est$n, all.est$max.est, type = "l", col="blue")
lines(p.estimates$n, p.estimates$max.est, col="red")

```



```{r}
m <- lm(y ~ x1 * x2 * I(x1*x2) * I(x1^2) * I(x2^2) * I(x1^2*x2) * I(x1*x2^2) * I(x1^3) * I(x2^3), data=d2) 

f <- paste(m$terms[[2]], m$terms[[1]], "t", c("", paste("+", attr(m$terms, "term.labels"))))

m.coef <- function(x, data=d2) { a <- lm(x, data=data) 
                                return(coef(a)[2]) }

m.l <- sapply(f, m.coef)

var(m.l)
max(m.l)
coefficients(m.l)[2]


```
