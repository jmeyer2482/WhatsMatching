---
title: "R Notebook"
output: html_notebook
---


```{r}
library(tidyverse)
library(MatchIt)
library(cem)
library(ggpubr)
library(cobalt)
library(data.table)

dt <- lalonde

```


```{r}

m <- glm(treat~educ+age, family=binomial(link = "logit"), data = lalonde)
m1 <- glm(treat~educ+age, family=quasibinomial(link = "logit"), data = lalonde)

all(m1$fitted.values == m$fitted.values)

m1 <- m

m1<- update(m, weights=fitted.values(m))

m$weights

summary(m1)
summary(m)

binomial(link = "logit")

```



```{r}
# f <- "treat~age+race+married"
# data <- dt
# control <- 0
# non.cont.vars <- c("race","married")



calc.matches <- 
    function(f=NULL, data=NULL, control=0, cat.vars=NULL, mod=NULL, match.grp=0:1,
             replace=TRUE) {
    
    if (is.null(mod)==FALSE){
        
        f <- formula(mod)
        if(is.null(data)==TRUE){ data <- model.frame(mod) }
    
    }   else { 
        
        if (is_formula(f)==FALSE){
            if(str_detect(f, "~")==FALSE){
            return("Error - formula not supplied to f")
            } else
            {f <- as.formula(f)}
        }
        
        treat.var <- all.vars(f)[1]
        match.vars <- all.vars(f)[2:length(all.vars(f))] 
    
    }
    
    treat.var <- all.vars(f)[1]
    match.vars <- all.vars(f)[2:length(all.vars(f))] 
    
    
    data <- cbind(id=rownames(data),
                  is.treated=ifelse(data[,treat.var]==control,0,1),
                  data)
    
    f <- update(f, is.treated ~ .)
    
      covs.mat <- get.covs.matrix(f, data)
    
    # !match.vars %in% non.cont.vars
    
    # mahal.vars
    
    # When the treatment variable is not a 0/1 variable, it will be coerced to one and returned as such in the matchit() output (see section Value, below). The following rules are used: 1) if 0 is one of the values, it will be considered the control and the other value the treated; otherwise, 2) if the variable is a factor, levels(treat)[1] will be considered control and the other variable the treated; otherwise, 3) sort(unique(treat))[1] will be considered control and the other value the treated. It is safest to ensure the treatment variable is a 0/1 variable.

    # data$treat <- ifelse(data[,treat.var]==control,0,1)
    
    # for (i in 1:length(match.vars)) {
    #     print(data[,match.vars[i]] %>%
    #               summarise(n_distinct/n)) 
    #     print(class(data[,match.vars[i]]))
    # }
    
    if (is.null(mod)==TRUE) { 
    # data %>% summarise(across(everything(),n_distinct))
    data$p.score <- fitted.values(glm(f, 
                                      data=data, family = binomial(link = "logit")))
    } else {
        data$p.score <- fitted.values(mod)
    }
    
    data$p.weight <- ifelse(data[,treat.var]==1,
                            1/data[,"p.score"],1/(1-data[,"p.score"]))
    
    Q <- quantile(data$p.score, prob=seq(from=0,to=1,by=0.2),na.rm=TRUE)
    data$p.strat <- cut(data$p.score, breaks = Q, labels = 1:5, include.lowest = TRUE)
    
    
    cat.vars.y <- paste0(cat.vars,".y")
    
    cont.vars <- match.vars[!match.vars %in% cat.vars]
    cont.vars.y <- paste0(cont.vars,".y")
    
    
    # !match.vars %in% non.cont.vars
    if (is.null(cat.vars)==FALSE) {
    dt.s <- full_join(data[c("id","is.treated", treat.var,match.vars,"p.score")],
                      data[c("id","is.treated", treat.var,match.vars,"p.score")],
                      suffix=c("",".y"),by=character()) %>% 
        cbind(m.dist=mah.dist(covs.mat)) %>%
        filter(is.treated!=is.treated.y & is.treated %in% match.grp) %>%
        .[apply(.[c(cat.vars)]==
                    .[c(cat.vars.y)],1,sum)==length(cat.vars),] %>%
        mutate(p.dist=abs(p.score-p.score.y))
    }
    
    if (is.null(cat.vars)==TRUE) {
    dt.s <- full_join(data[c("id","is.treated",treat.var,match.vars,"p.score")],
                      data[c("id","is.treated",treat.var,match.vars,"p.score")],
                      suffix=c("",".y"),by=character()) %>%
        cbind(m.dist=mah.dist(covs.mat)) %>%
        filter(is.treated!=is.treated.y & is.treated %in% match.grp) %>%
        mutate(p.dist=abs(p.score-p.score.y))
    }
    
    
    # dm <- as.matrix(dt.s[cont.vars]-dt.s[cont.vars.y])
    
    # print(dm)

    #covariance matrix
    # c <- cov(data[cont.vars])
    
    # cov.d <- solve(c,dm)
    
    # print(cov.d)
    # solve  (covariance matrix) %*% x = d for x
    # if (length(cont.vars)>1){
    # cov.d <- sapply(1:nrow(dt.s), function(x) solve(c,dm[x,])) %>% t()
    # } 
    # 
    # if (length(cont.vars)==1){
    # cov.d <- sapply(1:nrow(dt.s), function(x) solve(c,dm[x,]))  
    # }
    
    # print(c(
    #   dim(dm), "/n",
    #   dim(cov.d), "\n",
    #   length(cov.d))
    #   )
    
    # Mahalanobis calculation forced in two steps
    # dt.s$m.dist <- apply(dm*cov.d,1,sum)
    
    if (replace==TRUE) {
        
        p <- dt.s %>% group_by(id) %>% 
            # arrange(
            #   across(ends_with(".y") & !contains("id")  & !contains("is.treated"))
            #   ) %>% 
            slice_min(order_by = p.dist, with_ties = F) %>% 
            ungroup() %>% as.data.frame() 
        
        m <- dt.s %>% group_by(id) %>% 
            # arrange(
            #   across(ends_with(".y") & !contains("id")  & !contains("is.treated"))
            #   ) %>% 
            slice_min(order_by = m.dist, with_ties = F) %>% 
            ungroup() %>% as.data.frame()
        
    } else {
        p <- wout.replacement(data= dt.s, dist.var="p.dist")
        m <- wout.replacement(data= dt.s, dist.var="m.dist")
    }
    
    p <- p %>% select(-c(is.treated, is.treated.y))
    m <- m %>% select(-c(is.treated, is.treated.y))
    
    # return(dt.s)
    return(list(p=p,m=m,rd=dt.s))
}


wout.replacement <- function(data, dist.var) {
    d.dt <- as.data.table(data)

    setnames(d.dt, dist.var, "dist")
    
    setindex(d.dt, id, id.y)
    
    id = NULL
    ids = NULL
    
    for (i in unique(d.dt[,id])) {
        if(nrow(d.dt[!(id %in% ids) & !(id.y %in% ids)])>0){
        
            id <- d.dt[d.dt[!(id %in% ids[,1]) & !(id.y %in% ids[,2]),
                            .I[dist==min(dist)
                               ], by = id
                            ]$V1
                       ][order(dist), .(id,id.y,dist)][1]
          
            # id <- d.dt[order(-dist)
            #            ][!(id %in% ids) & !(id.y %in% ids), .(id,id.y,dist)
            #              ][dist==min(dist),
            #                ][1]
            
            #print(id)
            
            ids <- rbind(ids, id[,c(id,id.y)])
        }
    }
    
    # print(ids)
    # d.dt[(id == c(ids[,1]) & id.y == c(ids[,2])),]
    
    colnames(ids) <- c("id", "id.y")
    
    id.dt <- as.data.table(ids) 
    
    setnames(d.dt, "dist", dist.var)
    
    return(as.data.frame(
        d.dt[id.dt, on=.(id=id, id.y=id.y)]))
}



mah.dist <- function(X){  
  if(is.data.frame(X)==F) X <- as.data.frame(X)
  
  cx <- cov(X)
  mah.out <- sapply(1:nrow(X), function(i) {
    mahalanobis(x = X, 
                center = do.call("c", X[i, ]),
                cov = cov(X), tol = 1e-20)
  })
  
  # mah.out <- dist(mah.out, upper = T)
  
  return(as.vector(mah.out))
} 

```




```{r}
matched.c <- calc.matches(treat~age+educ+race, data=dt,# cat.vars = "race", 
                          match.grp = 1, replace=F)


match.out <- matchit(treat~age+educ+race, data=dt, replace = F)

match.out2 <- matchit(treat~age+educ+race, data=dt, distance="mahalanobis", 
                      replace = T) 

match.out2$weights
match.out3 <- matchit(treat~age+educ+race, data=dt, distance="mahalanobis", 
                      replace = T) 

# match.out$match.matrix==match.out2$match.matrix
# 
# 
# match.out2$match.matrix %>% unique()
# match.out$weights

m.p <- matched.c$p[c("id","id.y")]
m.m <- matched.c$m[c("id","id.y")]

m.p %>% mutate(id=as.numeric(id), id.y=as.numeric(id.y)) %>% arrange(id) %>%
  cbind(p.m=match.out$match.matrix) %>% filter(id.y!=p.m) #%>% view()

# id.diff <-
  m.m %>% mutate(idn=as.numeric(id), idn.y=as.numeric(id.y)) %>%
  arrange(idn) %>% cbind(m.m=match.out2$match.matrix) %>% filter(id.y!=m.m)# %>% view()

a1 <- matched.c$rd %>% inner_join(id.diff) %>% select(idn, age.y, educ.y)
# 
a2 <- matched.c$rd %>% inner_join(id.diff, by = c("id", "id.y"="m.m")) %>% select(idn, age.y, educ.y)
# # matched.c$rd %>% filter(near(mah.dist,m.dist,1e-14)==F)
a1-a2

# options(scipen = 99)
# as.(.1e-1)


# d <- matched.c$rd
# d.dt <- as.data.table(d.dt)
# setindex(d.dt, id, id.y)
# d.dt[!(id %in% c("165","27","9", "10", "11")) & 
#        !(id.y %in% c("186","187","515", "240", "325")),
#                        .(id,id.y,p.dist)][p.dist==min(p.dist)][1]
#             # print(id[,c(id,id.y)])
# rm(d.dt)
# 
# wout.replacement(d, "p.dist")

# d %>% slice_min(order_by = p.dist)

# inner_join(d, as.data.frame(list(id = rownames(match.out$match.matrix), 
                   # id.y = match.out$match.matrix)))
weights.subclass
```


```{r}
view(matched.c$rd)

matched.c$p

matched.c$rd %>% select(-c(is.treated, is.treated.y)) %>% 
  filter(race==race.y) %>% group_by(id) %>% arrange(p.dist) %>%
  slice_min(order_by = m.dist, with_ties = T) %>% ungroup() %>% arrange(as.numeric(id))


d %>% filter(id == m.p$id & id.y %in% m.p$id.y)# %>%
  # arrange(across(ends_with(".y") & !contains("id"))) #%>%  
  # slice_min(order_by = p.dist) #%>% first() %>% select(id,id.y)

inner_join(d, as.data.frame(list(id = rownames(match.out$match.matrix), 
                   id.y = match.out$match.matrix)))


wo.replacement <- function(data, dist.var) {
    # d.dt <- as.data.table(data)
    # 
    # setnames(d.dt, dist.var, "dist")
    # 
    # setindex(d.dt, id, id.y)
    # 
  # data <- d
  # dist.var <- "p.dist"
  
    colnames(data)[colnames(data) == dist.var] <- "dist"
  
    id = NULL
    ids = NULL
    
    for (i in unique(data$id)) {
        if(nrow(data %>% filter(!id %in% ids[,1] & !id.y %in% ids[,2]))>0){
        
          id <- data %>% filter(!id %in% ids[,1] & !id.y %in% ids[,2]) %>%
            arrange(id) %>%
              # across(ends_with(".y") & !contains("id"))) %>%
            slice_min(order_by = dist) %>% first() %>% select(id,id.y)
          
          # id <- d.dt[!(id %in% ids) & !(id.y %in% ids),
                       # .(id,id.y,dist)][dist==min(dist)][1]
            
            #print(id)
            
          ids <- rbind(ids, id[,c("id","id.y")])
          
        }
    }
    
    # print(ids)
    # d.dt[(id == c(ids[,1]) & id.y == c(ids[,2])),]
    
    # colnames(ids) <- c("id", "id.y")
    
    # id.dt <- (ids) 
    
    # setnames(d.dt, "dist", dist.var)
    colnames(data)[colnames(data) == "dist"] <- dist.var
    
    return(data %>% inner_join(ids))
}





```




```{r}
n.d <- calc.matches(f=treat~age+educ+race, data = dt, cat.vars = c("race"),
                    match.grp=0, replace=TRUE)

n.d[[1]] %>%
    ggplot(aes(age, educ)) + geom_point(color="red", alpha = 0.5) + 
    geom_point(aes(age.y, educ.y), color="blue", alpha = 0.5) +
    geom_segment(aes(x=age, xend=age.y, y=educ, yend=educ.y))

n.d[[2]] %>%
    ggplot(aes(age, educ)) + geom_point(color="red", alpha = 0.5) + 
    geom_point(aes(age.y, educ.y), color="blue", alpha = 0.5) +
    geom_segment(aes(x=age, xend=age.y, y=educ, yend=educ.y))

n.d[[1]] %>%
    ggplot(aes(re74, educ)) + geom_point(color="red", alpha = 0.5) + 
    geom_point(aes(re74.y, educ.y), color="blue", alpha = 0.5) +
    geom_segment(aes(x=re74, xend=re74.y, y=educ, yend=educ.y))

n.d[[2]] %>%
    ggplot(aes(re74, educ)) + geom_point(color="red", alpha = 0.5) + 
    geom_point(aes(re74.y, educ.y), color="blue", alpha = 0.5) +
    geom_segment(aes(x=re74, xend=re74.y, y=educ, yend=educ.y))

n.d[[1]] %>%
    ggplot(aes(age, re74)) + geom_point(color="red", alpha = 0.5) + 
    geom_point(aes(age.y, re74.y), color="blue", alpha = 0.5) +
    geom_segment(aes(x=age, xend=age.y, y=re74, yend=re74.y))

n.d[[2]] %>%
    ggplot(aes(age, re74)) + geom_point(color="red", alpha = 0.5) + 
    geom_point(aes(age.y, re74.y), color="blue", alpha = 0.5) +
    geom_segment(aes(x=age, xend=age.y, y=re74, yend=re74.y))


n.d[[1]] %>%
ggplot(aes(p.score,p.score.y, color=p.dist)) + 
  geom_abline(slope=1) + geom_point() + theme_classic() + lims(x=c(0,1),y=c(0,1)) 

n.d[[2]] %>%
ggplot(aes(p.score,p.score.y, color=m.dist)) + 
  geom_abline(slope=1) + geom_point(alpha=0.3) + theme_classic() + lims(x=c(0,1),y=c(0,1)) 



# sum(lalonde$treat==1)

# wout.replacement(data= n.d, dist.var="m.dist")

# unique(n.d$id)
# colnames(d.dt[,"dist"]) <- "dist1"

# colnames(d.dt)
# formula(m1)

view(n.d[[1]])

```




```{r}
n.d <- calc.matches(f=treat~age+educ+re74, data = dt, #cat.vars = c("married"),
                    match.grp=0, replace=TRUE)

n.d[[1]] %>%
    ggplot(aes(age, educ)) + geom_point(color="red", alpha = 0.5) + 
    geom_point(aes(age.y, educ.y), color="blue", alpha = 0.5) +
    geom_segment(aes(x=age, xend=age.y, y=educ, yend=educ.y, alpha = p.dist)) +
    scale_alpha_continuous(range=c(1,0), limits = c(0,1)) +
    lims(x=c(min(dt$age),max(dt$age)), y=c(min(dt$educ),max(dt$educ)))

n.d[[2]] %>%
    ggplot(aes(age, educ)) + geom_point(color="red", alpha = 0.5) + 
    geom_point(aes(age.y, educ.y), color="blue", alpha = 0.5) +
    geom_segment(aes(x=age, xend=age.y, y=educ, yend=educ.y, alpha = m.dist)) +
    scale_alpha_continuous(range=c(1,0)) +
    lims(x=c(min(dt$age),max(dt$age)), y=c(min(dt$educ),max(dt$educ)))

n.d[[1]] %>%
    ggplot(aes(re74, educ)) + geom_point(color="red", alpha = 0.5) + 
    geom_point(aes(re74.y, educ.y), color="blue", alpha = 0.5) +
    geom_segment(aes(x=re74, xend=re74.y, y=educ, yend=educ.y), alpha = 0.5) +
    lims(x=c(min(dt$re74),max(dt$re74)), y=c(min(dt$educ),max(dt$educ)))

n.d[[2]] %>%
    ggplot(aes(re74, educ)) + geom_point(color="red", alpha = 0.5) + 
    geom_point(aes(re74.y, educ.y), color="blue", alpha = 0.5) +
    geom_segment(aes(x=re74, xend=re74.y, y=educ, yend=educ.y), alpha = 0.5) +
    lims(x=c(min(dt$re74),max(dt$re74)), y=c(min(dt$educ),max(dt$educ)))

n.d[[1]] %>%
    ggplot(aes(age, re74)) + geom_point(color="red", alpha = 0.5) + 
    geom_point(aes(age.y, re74.y), color="blue", alpha = 0.5) +
    geom_segment(aes(x=age, xend=age.y, y=re74, yend=re74.y), alpha = 0.5) +
    lims(x=c(min(dt$age),max(dt$age)), y=c(min(dt$re74),max(dt$re74)))

n.d[[2]] %>%
    ggplot(aes(age, re74)) + geom_point(color="red", alpha = 0.5) + 
    geom_point(aes(age.y, re74.y), color="blue", alpha = 0.5) +
    geom_segment(aes(x=age, xend=age.y, y=re74, yend=re74.y), alpha = 0.5) +
    lims(x=c(min(dt$age),max(dt$age)), y=c(min(dt$re74),max(dt$re74)))

n.d[[1]] %>%
ggplot(aes(p.score,p.score.y, color=p.dist)) + 
  geom_abline(slope=1) + geom_point() + theme_classic() + lims(x=c(0,1),y=c(0,1)) 

n.d[[1]] %>%
ggplot(aes(p.score,p.score.y, color=m.dist)) + 
  geom_abline(slope=1) + geom_point() + theme_classic() + lims(x=c(0,1),y=c(0,1)) 


n.d[[2]] %>%
ggplot(aes(p.score,p.score.y, color=p.dist)) + 
  geom_abline(slope=1) + geom_point() + theme_classic() + lims(x=c(0,1),y=c(0,1)) 

n.d[[2]] %>%
ggplot(aes(p.score,p.score.y, color=m.dist)) + 
  geom_abline(slope=1) + geom_point() + theme_classic() + lims(x=c(0,1),y=c(0,1)) 


```




```{r}

set.seed(1)

#cartesian join to match all possible combinations
d <- list(id = 1:10, t = rep(c(0,1),5), score = rnorm(10)) %>% 
    as.data.frame() %>% 
    full_join(.,.,by=character(),suffix=c("",".y")) %>% 
    filter(id!=id.y, t!=t.y) %>%
    mutate(dist=abs(score-score.y))

#get the row with the minimum distance
d %>% group_by(id) %>%
    slice_min(order_by = c(dist,id), with_ties = FALSE)

# d[which.min(d$dist),]




d.dt <- as.data.table(d)

id = NULL
ids = NULL

for (i in (d$id %>% unique())) {
    
    id <- d.dt[!(id %in% ids[,1]) & !(id.y %in% ids[,2]),
                .(id,id.y,dist)][dist==min(dist)][1]

    ids <- rbind(ids, id[,c(id,id.y)])

}

d.dt[(id == c(ids[,1]) & id.y == c(ids[,2])),mult="all"]

colnames(ids) <- c("id", "id.y")

id.dt <- as.data.table(ids) 

d.dt[id.dt, on=.(id=id, id.y=id.y)]

```



```{r}

n.d <- calc.matches(f=treat~age+educ+re74, data = dt, #cat.vars = c("married"),
                    match.grp=1, replace=FALSE)


match <- matchit(treat~age+educ+re74, data=dt, replace = FALSE, m.order = "smallest", caliper = 0.1, std.caliper = TRUE)


a <- match.data(match) 

cbind(match$match.matrix,match$distance,)

# 292-185

n.d$p %>% select(id.y) %>% unique()

n.d$p$p.score
a$distance
inner_join(n.d$p, a, by = c("p.score"="distance"))

```



```{r}

f<-treat~age+educ

bal <- NULL
n <- Inf

for (i in seq(15000,0,by=-10)) {
  c <- i*0.0001
  match <- matchit(f, data=dt, replace = TRUE, method = "nearest",
                   distance = "glm", caliper = c(age=c,educ=c), std.caliper = TRUE) %>%
    match.data()
  # a<- match.data(match)
  # p <- ggplot(data=a, aes(age, educ, color=treat, group=subclass)) + 
  #   geom_point(alpha=0.2) +
  #   geom_line(color="grey30", alpha=0.3) + lims(x=c(15,60), y=c(0,17))
  # print(p)
  
  if (nrow(match)<n){
    b <- cobalt::bal.tab(f,match,s.d.denom="pooled")$Balance
    bal <- rbind(cbind(caliper=c,n=nrow(match),v=rownames(b),b),
      bal, make.row.names=FALSE) 
    
    }
  
  n <- nrow(match)
  
  }

ggplot(bal, aes(n,Diff.Un, color=v)) + geom_line() + scale_x_reverse()
bal
# 
# b <- cobalt::bal.tab(f,a)
# 
# 
# b$Balance 
```

```{r}

ggplot() + geom_line(aes(n, Diff.Un, group=row))


get.covs.matrix(treat~age+educ+race, dt) %>% as.data.frame() %>% 
  arrange(across(!contains("age")&!contains("black")))
```


```{r}

#Get covariates (RHS) vars from formula
get.covs.matrix <- function(formula = NULL, data = NULL) {

  if (is.null(formula)) {
    fnames <- colnames(data)
    fnames[!startsWith(fnames, "`")] <- paste0("`", fnames[!startsWith(fnames, "`")], "`")
    formula <- reformulate(fnames)
  }
  else formula <- update(terms(formula, data = data), NULL ~ . + 1)

  mf <- model.frame(terms(formula, data = data), data,
                    na.action = na.pass)

  chars.in.mf <- vapply(mf, is.character, logical(1L))
  mf[chars.in.mf] <- lapply(mf[chars.in.mf], factor)

  X <- model.matrix(formula, data = mf,
                    contrasts.arg = lapply(Filter(is.factor, mf),
                                           contrasts, contrasts = FALSE))
  assign <- attr(X, "assign")[-1]
  X <- X[,-1,drop=FALSE]
  attr(X, "assign") <- assign

  return(X)
}


#Generalized inverse; port of MASS::ginv()
generalized_inverse <- function(sigma) {
  sigmasvd <- svd(sigma)
  pos <- sigmasvd$d > max(1e-8 * sigmasvd$d[1L], 0)
  sigma_inv <- sigmasvd$v[, pos, drop = FALSE] %*% (sigmasvd$d[pos]^-1 * t(sigmasvd$u[, pos, drop = FALSE]))
  return(sigma_inv)
}

#Choleski decomp for non-negative definite matrices
chol2 <- function(Sinv) {
  ch <- suppressWarnings(chol(Sinv, pivot = TRUE))
  p <- order(attr(ch, "pivot"))
  return(ch[,p])
}


dist.matrix <- function(mat, cov.m) {
  return(
    apply(mat*cov.m, 1, sum)
  )
  
}


#Turn a vector into a 0/1 vector. 'zero' and 'one' can be supplied to make it clear which is
#which; otherwise, a guess is used. From WeightIt.
binarize <- function(variable, zero = NULL, one = NULL) {
  if (length(unique(variable)) > 2) stop(paste0("Cannot binarize ", paste(deparse(substitute(variable)), collapse = " "), ": more than two levels."))
  if (is.character(variable) || is.factor(variable)) {
    variable <- factor(variable, nmax = 2)
    unique.vals <- levels(variable)
  }
  else {
    unique.vals <- unique(variable, nmax = 2)
  }

  if (is.null(zero)) {
    if (is.null(one)) {
      if (can_str2num(unique.vals)) {
        variable.numeric <- str2num(variable)
      }
      else {
        variable.numeric <- as.numeric(variable)
      }

      if (0 %in% variable.numeric) zero <- 0
      else zero <- min(variable.numeric, na.rm = TRUE)

      return(setNames(as.integer(variable.numeric != zero), names(variable)))
    }
    else {
      if (one %in% unique.vals) return(setNames(as.integer(variable == one), names(variable)))
      else stop("The argument to 'one' is not the name of a level of variable.", call. = FALSE)
    }
  }
  else {
    if (zero %in% unique.vals) return(setNames(as.integer(variable != zero), names(variable)))
    else stop("The argument to 'zero' is not the name of a level of variable.", call. = FALSE)
  }
}


mah.dist <- function(X){  
  if(is.data.frame(X)==F) X <- as.data.frame(X)
  
  cx <- cov(X)
  mah.out <- sapply(1:nrow(X), function(i) {
    mahalanobis(x = X, 
                center = do.call("c", X[i, ]),
                cov = cov(X), tol = 1e-20)
  })
  
  return(sqrt(as.vector(mah.out)))
}

data.table::set()
```



```{r}
# library(StatMatch)
# library(HDMD)

mahcovs <- get.covs.matrix(treat~age+educ+race, data=dt) 

    # if (is.null(s.weights))
      mahSigma_inv <- generalized_inverse(cov(mahcovs))
    # else
      # mahSigma_inv <- generalized_inverse(cov.wt(mahcovs, s.weights)$cov)
    mahcovs.d <- tcrossprod(mahcovs, chol2(mahSigma_inv))
    
    # mahcovs[.e,,drop = FALSE]
    dm <- as.matrix(dt.s[,cont.vars]-dt.s[,cont.vars.y])

    #covariance matrix
    c <- cov(data[cont.vars])
    
    # solve  (covariance matrix) %*% x = d for x
    cov.d <- sapply(1:nrow(dt.s), function(x) solve(c,dm[x,])) %>% t()
    
    # Mahalanobis calculation forced in two steps
    dt.s$m.dist <- apply(dm*mahcovs, 1, sum)
    
    
dist.matrix(get.covs.matrix(treat~age+educ+race, data=dt), mahcovs) 


mah.dist(mahcovs, mahSigma_inv)


view(dist(m1$fitted.values,upper=T) %>% as.matrix())

mahalanobis.dist(mahcovs)

HDMD::pairwise.mahalanobis(mahcovs, dt$treat, tol = 1e-20)


HDMD::bHLH288[,1]


mah.dist <- function(X, t, cov.m=cov(X)){  

  if (!is.list(X)) X <- as.data.frame(X)
  
  out <- sapply(1:nrow(X), function(i) {
    
    mahalanobis(x = X, 
                center = do.call("c", X[i, ]),
                cov = cov.m, tol = 1e-20)
  })
  
  out <- as.matrix(out[t==1,t==0])
  # , 
                # dimnames = list(rownames(X[t==0,]),rownames(X[t==0,])) )
  rownames(out) <- rownames(X[t==1,])
  colnames(out) <- rownames(X[t==0,])
  return(out)
}

cov(mahcovs)

is.list(mahcovs)

rownames(mahcovs[dt$t==0])

class(mahcovs)

mahcovs <- get.covs.matrix(treat~age+educ+race, data=dt) 
m.dists <- mah.dist(mahcovs, t=dt$t)

m.dists <- dist(mah.dist(mahcovs, t=dt$t),upper=T) %>% as.matrix()
p.dists <- dist(m1$fitted.values,upper=T) %>% as.matrix()

matched.c <- calc.matches(treat~age+educ+race, data=dt, cat.vars = "race", 
                          match.grp = 1)


match.out <- matchit(treat~age+educ+race, data=dt)

match.out2 <- matchit(treat~age+educ+race, data=dt, distance="mahalanobis", exact=~race) 

match.out$match.matrix==match.out2$match.matrix

binarize()
```


```{r}
# library(match2C)

mahcovs <- get.covs.matrix(treat~age+educ+married+nodegree, data=dt) 
m.dists <- mah.dist(mahcovs, t=dt$t)

match2c.out <- create_list_from_scratch(dt$treat, mahcovs, exact = NULL, method = 'maha') 

185*429

sum(near(matrix(match2c.out$d,nrow=185, ncol=429, byrow = T), m.dists,tol=1e-10))


sum(near(matrix(match2c.out$d), mahcovs.d,tol=1e-10))


# matrix(match2c.out$d,nrow=185, ncol=429, byrow = T) - m.dists
# 
# as.double(1e-100)
# 
# sprintf("%1.100f",1e-100)
# 
# 
# arrayInd(which.min(m.dists), m.dists)
view(lalonde)
```


```{r}
n.d <- calc.matches(f=treat~age+educ+race, data = dt, cat.vars = c("race"),
                    match.grp=0, replace=TRUE)

view(n.d[[2]])
view(n.d[[1]])

glm(treat~age+educ, dt, family="binomial") %>% summary()
```


```{r}

ggplot(n.d[[1]]) + geom_point(aes(p.dist, m.dist), alpha=0.2)

ggplot(n.d[[2]]) + geom_point(aes(p.dist, m.dist), alpha=0.2)

```



```{r}
tf <- function(model, ...) {
  m <- update(model, ...)
  return(m)
}

md <- glm(treat~age+educ, dt, family="binomial")

tf(md, formula=treat~race)


```



```{r}


# infert.m <- calc.matches(case~education+age, infert, cat.vars = "education")
mah.dist <- function(X){  
  if(is.data.frame(X)==F) X <- as.data.frame(X)
  
  cx <- cov(X)
  mah.out <- sapply(1:nrow(X), function(i) {
    mahalanobis(x = X, 
                center = do.call("c", X[i, ]),
                cov = cov(X), tol = 1e-20)
  })
  
  # mah.out <- dist(mah.out, upper = T)
  
  return(as.vector(mah.out))
}


# m.dists <- mah.dist(lalonde[c("age", "educ")])


# view(m.dists)

# 614*614

# c.m <- cov(get.covs.matrix(treat~age+educ+race,dt))

# sum(near(mah.dist(get.covs.matrix(treat~age+race+married,dt) %>% as.data.frame()), mah.dist(get.covs.matrix(treat~age+educ,dt) %>% as.data.frame()), tol=1e-10))


mah.dist(get.covs.matrix(treat~age+race+married,dt))

view(matched.c$p)

```




```{r}
# d <- as.data.table(d)
# d

# d[ , min(p.dist), by=id]

# d[min(p.dist), .(id.y), by = id]

d[d[!id %in% c("69","58") & !id.y %in% c("539","605"), .I[p.dist==min(p.dist)], by = id]$V1][order(-p.dist), .(id,id.y,p.dist)][1]

# d[p.dist, c( lapply(.SD, min)), by=id]

d[d[, .I[id==d[ , mean(p.dist), by = id][order(-V1)][1]$id]]][order(p.dist)][1]
```

```{r}

mean(matched.c$p$age-matched.c$p$age.y)

mean(matched.c$m$age-matched.c$m$age.y)

mean(matched.c$p$age-matched.c$p$age.y)

mean(matched.c$m$age-matched.c$m$age.y)

```



