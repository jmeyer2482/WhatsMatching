---
title: "PSM ShinyApp Plan"
author: "Jason Meyer"
date: "25/03/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(MatchIt)
# library(cem)
# library(ggpubr)
library(optmatch)
# library(cobalt)
library(ggplot2)
library(dplyr)
# library(tidyverse)
library(catdata)
library(mplot)
# library(purrr)
# library(ggforce)
# library(dagitty)
# library(dagR)
library(plotly)
# library(gapminder)
# library(gganimate)

```

# Shiny app for the exploration of the PSM paradox

Take simulated or pre-existing `R` data sets and use them to generate graphical outputs that provide intuitive insights into how the propensity operates.

Available data sets for this project will include `lalonde` which is used as example data for matching in the `MatchIt` and `optmatch` packages. Additionally, the `fev` data set available in `mplot` and the `heart` dataset from `catdata`. Two of these data sets have health data and supply a binary outcome (`heart`) and continuous outcome (`fev`). The data sets are all complete and have no missing data therefore there is no need for cleaning or pre-processing. 


```{r real data, include=TRUE}

data("heart", catdata)
data("lalonde")
fev <- mplot::fev

head(lalonde)

head(heart)

head(fev)

```


## Simulated data

Ideas for simulated data:
- causal diagram to represent the relationship between the variables
  + suggest independent, dependent, confounding and colliding as options
- ability to change treatment effect
- ability to change distribution of data (eg uniform, normal, poisson, binomial)
- select up to 3 variables 


```{r sim data}

###REVIEWING DISTRIBUTIONS
#normal distribution
# rnorm(n, mean = 0, sd = 1)
# rnorm(200, 27, 5.5) %>% hist(main="Normal Distribution")

#uniform distribution
# runif(n, min = 0, max = 1)
# runif(200, 10, 30) %>% hist(main="Uniform Distribution")


#binomial distribution
# rbinom(n, size, prob)
# rbinom(200,5,0.5) %>% table()# LETTERS[.]# hist(main="Binomial Distribution")


sim.cont.d <- 
  function(TE=2, x1=runif(200,0,5), x2=runif(200,0,5), cause="dependent") {
    
    if (is.character(cause)) cause <- switch(cause,
                      dependent = 1,
                      independent = 2,
                      confounding = 3,
                      colliding = 4)
    if (!cause %in% 1:4) stop("cause must be a named variable or number between 1 and 4")
    
    #randomly generate a treatment variable with approximately 50/50 split
    t <- rbinom(length(x1),1,0.5)
    
    #dependent
    # pathways: t -> x1 -> y
    #           t -> x2 -> y
    #           t -> y
    if (cause==1){
      x1 <- x1 + t #t->x1
      x2 <- x2 + t #t->x2
      y <- TE*t + x1 + x2 + rnorm(length(t),0,0.3) #t->y, x1->y, x2->y
    }
    
    #independent
    # pathways: t -> x1 -> x2 -> y
    #           t -> y
    if (cause==2){
      x1 <- x1 + t #t->x1
      x2 <- x2 / x1 #x1->x2
      y <- TE*t + x1 + x2 + rnorm(length(t),0,0.3) #t->y, t->x1->x2->y
    }
    
    #confounding
    # pathways: x2 -> x1 -> t
    #           x2 -> y
    #           t -> y
    if (cause==3){
      x1 <- x1 + x2 #x2-> x1
      t <- ifelse(x1>quantile(x1, 0.5), 1, 0) #x1->t
      y <- TE*t + x2 + rnorm(length(t),0,0.3) #x2->y, t->y
    }
    
    #colliding
    # pathways: t -> x1 -> x2
    #           y -> x2
    #           t -> y
    if (cause==4){
      x1 <- x1 + t #t->x1
      y <- TE*t + rnorm(length(t),20,2) #t->y
      x2 <- x2 + x1 + y #x1->x2, y->x2
    }
    

    d <- list(t=t,x1=x1,x2=x2,y=y) %>% as.data.frame()

    return(d)
  }


sim.data <- function(n=200, TE=2,oc="continuous",x1=runif(n,0,5),
                     x2=runif(n,0,5),x3=1, x4=1, x5=1){
  
  t <- c(rep(1,n/2),rep(0,n/2)) 
  x5 <- t * x5
  x1 <- x1 + t
  x2 <- x2 + t
  x3 <- x3 + x2 + t
  y <- x3 + x1 + x5 + t*TE
  if (oc!="continuous") y <- ifelse(y>quantile(y, 0.5), 1, 0)
  x4 <- t + y
  
  cbind(t,x1,x2,x3,x4,x5,y)
}


# sim.data()


# 
# n <- 200
# x1 <- rnorm(n, 50, 7)
# x2 <- runif(n, 10, 25)
# 
# for (i in 1:4) {
#   d <- sim.cont.d(x1=x1, x2=x2, cause = i) 
#   
#   # (d %>% ggplot(aes(x1,x2,color=t)) + geom_point()) %>%
#     # print(.)
#   (d %>% ggplot(aes(x1,x2,shape=factor(t),color=y)) + geom_point() +
#       scale_color_viridis()) %>%
#     print(.)
#   
# }
# 
# 
# 
# sim.cont.d(cause = "independent") %>% ggplot(aes(x1,x2,color=t)) + geom_point()
# sim.cont.d(cause = "confounding") %>% ggplot(aes(x1,x2,color=t)) + geom_point()
# sim.cont.d(cause = "colliding") %>% ggplot(aes(x1,x2,color=t)) + geom_point()
# 
# 
# sim.cont.d(cause = "dependent") %>% ggplot(aes(t,y,color=t)) + geom_jitter()
# sim.cont.d(cause = "independent") %>% ggplot(aes(t,y,color=t)) + geom_jitter()
# sim.cont.d(cause = "confounding") %>% ggplot(aes(t,y,color=t)) + geom_jitter()
# sim.cont.d(cause = "colliding") %>% ggplot(aes(t,y,color=t)) + geom_jitter()
# 
# x4 <- runif(100,1,20)
# ifelse(x4>quantile(x4, 0.7),1,0)
# 
# quantile(x4, 0.7)
# 
# rbinom(200,1,0.5) %>% table()
# 
# rnorm(200,0,0.3) %>% hist()

create.sim1.data <- function(){
  t = c(rep(0, 25),rep(1, 25),rep(0, 25),rep(1, 25),rep(0, 50))
  g = c(rep("Paired", 50), rep("Random", 50), rep("Controls", 50))
  
  px1c <- runif(25, min = -2, max = 2)
  px2c <- runif(25, min = -2, max = 2)
  px1t <- px1c + runif(25, min = -0.05, max = 0.05)
  px2t <- px2c + runif(25, min = -0.05, max = 0.05)
  
  rx1 <- runif(50, min = -2, max = 2)
  rx2 <- runif(50, min = -8, max = -4)
  
  cx1 <- runif(50, min = -6, max = -4)
  cx2 <- runif(50, min = -8, max = 2)
  
  x1 <- c(px1c, px1t, rx1, cx1)
  x2 <- c(px2c, px2t, rx2, cx2)
  
  y <- t*2 + x1 + x2
  
  data <- as.data.frame(list(x1=x1, x2=x2, t=t, g=g, y=y))

  return(data)
}


create.sim2.data <- function() {
    
    x1 <- c(runif(100, 0,5),runif(100, 1,6))
    x2 <- c(runif(100, 0,5),runif(100, 1,6))
    t.char <- c(rep("C",100),rep("T",100))
    t <- ifelse(t.char=="C",0,1)
    y <- 2*t + x1 + x2 + rnorm(200)
    
    d <- list(x1=x1,x2=x2,t=t, t.char=t.char, y=y) %>% as.data.frame()
    
    return(d)
}
```


Let's look at the `fev` data.

```{r data visuals}

# f <- smoke~age+height+sex
# 
# f.vars <- all.vars(f)
# 
# d <- mplot::fev
# 
# # ggplot(d, aes_string(f.vars[2], f.vars[3])) +
# #   geom_point(aes(shape=as.factor(.data[[f.vars[1]]]))) +
# #   scale_shape_manual(name="Smoker", values = c(1,2), labels = c("No","Yes")) +
# #   facet_grid(~.data[[f.vars[1]]])
# 
# ggplot(d, aes(age, height, shape=as.factor(smoke))) +
#   geom_point() + #facet_grid(~smoke) + 
#   geom_mark_hull(expand=unit(2.5,'mm'),aes(fill=as.factor(smoke)))
# 
# 
# ggplot(d, aes(sex, height, fill=as.factor(smoke))) + geom_boxplot()
# 
# ggplot(d, aes(sex, age, fill=as.factor(smoke))) + geom_boxplot()
# 
# # library(catdata)
# 
# # data(heart)
# 
# 
# #matched data
# d.matched <- matchit(f, d) %>% match.data()
# 
# ggplot(d.matched, aes(age, height, shape=as.factor(smoke))) +
#   geom_point() + #facet_grid(~smoke) + 
#   geom_mark_hull(expand=unit(2.5,'mm'),aes(fill=as.factor(smoke)))
# 
# 
# ggplot(d.matched, aes(sex, height, fill=as.factor(smoke))) + geom_boxplot()
# 
# ggplot(d.matched, aes(sex, age, fill=as.factor(smoke))) + geom_boxplot()
# 
# 
# 
# d.weighted <- d
# d$pscore <- glm(smoke~age+sex+height, d.weighted, family = "binomial") %>%
#   fitted()
# 
# d.weighted$weight <- (d.weighted$smoke/d.weighted$pscore) +
#                       ((1-d.weighted$smoke)/(1-d.weighted$pscore))
# 
# Q <- quantile(d.weighted$pscore[d.weighted$smoke==1], seq(0, 1, 0.2))
# d.weighted$strat <- cut(d.weighted$pscore,breaks= Q, include.lowest = T
#                         , labels=1:5)


```

Let's compare the estimates for the `fev` data using the raw data then using other propensity score methods.

```{r}

# fmls <- c(fev~smoke, fev~age+height+sex+smoke)
# treatment <- "smoke"
# 
# 
# for (i in fmls) {
# #vanilla
# mod.v <- lm(i, d)
# raw <- cbind(estimate=coef(mod.v),confint(mod.v))[treatment,]
# #no variable adjustment smoking increases fev by 0.71 (95% CI 0.49 to 0.93) 
# #taking into accout age, sex, and ht, 
# #smoking decreases fev by -0.09 (95% CI -0.2 to 0.03) 
# 
# 
# #vanilla matching
# mod.v.m <- lm(i, d.matched)
# matched <- cbind(estimate=coef(mod.v.m),confint(mod.v.m))[treatment,]
# #no variable adjustment smoking decreases fev by -0.33 (95% CI -0.62 to -0.05) 
# #taking into accout age, sex, and ht, 
# #smoking decreases fev by -0.17 (95% CI -0.35 to 0.002) 
# 
# #weighting
# ATE.weight <- with(d, smoke/pscore + (1-smoke)/(1-pscore))
# ATT.weight <- with(d, smoke + (1-smoke)*((1-smoke)/(1-pscore)))
# 
# 
# mod.v.m.w <- lm(i, d, weights = ATE.weight)
# weighted <- cbind(estimate=coef(mod.v.m.w),confint(mod.v.m.w))[treatment,]
# #no variable adjustment smoking increases fev by 0.12 (95% CI -0.02 to 0.26) 
# #taking into accout age, sex, and ht, 
# #smoking decreases fev by -0.21 (95% CI -0.29 to -0.14)
# 
# d.strat <- d.weighted[!is.na(d.weighted$strat),]
# 
# tmp <- by(d.strat, d.strat$strat, function(x) lm(i, data=x))
# stratified <- cbind(estimate=apply(sapply(tmp, coef), 1, mean),
#                     apply(sapply(tmp, confint),1,mean) %>% 
#                       matrix(ncol=2, 
#                              dimnames = list(rownames(confint(tmp[[1]])),
#                                              colnames(confint(tmp[[1]]))
#                                              ))
#                     )[treatment,]
# 
# rbind(raw, matched, weighted, stratified) %>% print()
# 
# }
# #no variable adjustment smoking decreases fev by -0.13 (95% CI -0.65 to 0.38) 
# #taking into accout age, sex, and ht, 
# #smoking decreases fev by -0.12 (95% CI -0.45 to 0.20)
# 
# ATE.weight[ATE.weight!=ATT.weight]
# ATT.weight[ATE.weight!=ATT.weight]

```




```{r}
# #use optmatch to get the distance matrix
# f <- smoke ~ age + height + sex 
# 
# p.scores <- glm(formula = f, data = d, family = "binomial")
# 
# # prop.matrix <- 
#   optmatch::match_on(p.scores$fitted.values,z=p.scores$y)
#   
#   
# maha.matrix <- optmatch::match_on(f, data = d, method = "mahalanobis")
# 
# 
# distance.matrix(f, d, dist = "mahalanobis")


```




```{r}

##MATCHING FUNCTIONS

#get a distance matrix based on the distance method of propensity or mahalanobis
distance.matrix <- function(f, data, dist = "propensity"){
  #f 
  #a two sided formula containing the treatment variable
  #on the left side and the matching variables on the right
  
  #data
  #the data that is to be used for matching
  
  #dist
  #a matching distance. Either "propensity" or "mahalanobis"
  
  #calculate the propensity score using logistic regression
  p.scores <- glm(formula = f, data = data, family = "binomial")
  
  #create a distance matrix using optmatch based on selected distance
  #the matrix returned is n x p where n is treated and p is control
  #each value is a distance between a treated and control unit
  if (dist=="propensity"){
    dist <- optmatch::match_on(x=p.scores$fitted.values, z=p.scores$y)
  } else if (dist=="mahalanobis"){
    dist <- optmatch::match_on(x = f, data = data, 
                               method = "mahalanobis")
  }
  
  #return the distance matrix and the propensity scores used to create it
  #if the propensity score method was used.
  return(list(d.m=dist, p.scores=p.scores$fitted.values))
}

##This function returns pairs of row IDs for the matches of a n x p matrix of distances
dist.matches <- function(d.m, order=NULL, replace=FALSE){
  #d.m
  #a distance matrix
  
  #order
  #a vector of ordering which should be the same length as 
  #nrows(d.m)
  
  #replace
  #boolean value of whether to replace matched units or not
  
  d.mat <- d.m@.Data
  
  t.names <- attributes(d.mat)$dimnames$treatment
  c.names <- attributes(d.mat)$dimnames$control
  
  #order by the data if no order specified
  if (is.null(order)) order <- seq_along(t.names)
  
  
  #initialise a dataframe for storing matched pairs
  ids <- list(treatment=character(), 
              control=character(), 
              dist=numeric()
              ) %>% as.data.frame()

  #loop over the distance matrix rows using the order specified
  for (i in t.names[order]) {
    #select the row
    #if replace is TRUE then only allow columns that have not been used
    if (replace) {
        d <- d.mat[i,]
      } else {
        d <- d.mat[i,!c.names %in% ids$control]
      }
    
    c.val <- names(which.min(d))
    if (length(d)==1) c.val <- c.names[!c.names %in% ids$control]

      #NOT REQUIRED 
      # if (inc.equ) {
      #   nms <- names(which(d==min(d)))
      #   a <- list(treatment = rep(as.character(i), length(nms)), 
      #             control = nms, 
      #             dist = rep(min(d), length(nms)))
      # } else {
      a <- list(treatment = i,
                control = c.val,
                dist = min(d))
      # }
      
      #add the matched pair to the dataframe
      ids <- rbind(ids,a)
      
      row.names(ids) <- 1:nrow(ids)
      
  }
  
  #return all the matched pairs with the score they were matched on
  #dataframe with nrow(d.m) rows and 3 cols.
  return(ids)
}


#a function to calculate the propensity score with weighting and stratification variables
dists <- function(f, prop.s, data) {
  #f
  #a two sided formula containing the treatment variable
  #on the left side and the matching variables on the right
  
  #data
  #the data that is to be used for matching
  
    #get the response variable from the formula
    t = data[[all.vars(f)[1]]]
    
    #not currently required
    # #check the response is binary for logistic regression
    # if(all(as.numeric(data[t] == data[1,t]) %in% c(0,1))) {
    #     data[t] <- as.numeric(data[t] != data[1,t])
    # }
    
    #calculate the propensity score using logistic regression
    # prop.s <- glm(f, data=data, family = "binomial") %>% fitted()
    
    #make an id column and add propensity scores to the data
    dt <- cbind(idx = row.names(data), data, prop.s)
    
    #add ATE weight to the data
    dt$ATE.wt <- t/prop.s + (1-t)/(1-prop.s)
    
    #add ATT weight to the data
    dt$ATT.wt <- t + (1-t)*prop.s/(1-prop.s)
    
    #split the propensity score into 5 even groups
    Q <- quantile(prop.s, prob=seq(from=0,to=1,by=0.2),na.rm=TRUE)
    #create a stratification variable.
    dt$prop.st <- cut(prop.s, breaks = Q, labels = 1:5, 
                      include.lowest = TRUE)
    
    #return the additional data
    return(dt)
}


matched.data <- function(f, data, dist, order="data", replace=FALSE){
  #f
  #a two sided formula containing the treatment variable
  #on the left side and the matching variables on the right
  
  #data
  #the data that is to be used for matching
  
  #dist
  #a matching distance. Either "propensity" or "mahalanobis"

  #order
  #a named order of "data", "smallest", "largest", "random" 
  #used to perform matches and is only relevant if replace = TRUE
  #"data" just uses the order the data is already in
  #"smallest" matches by the smallest propensity score first
  #"largest" matches by the largest propensity score first
  #"random" matches on a random order every time
  
  #replace
  #boolean value of whether to replace matched units or not
  
  #get the distance matrix
  d.m <- distance.matrix(f=f,data=data,dist=dist)
  p.scores <- d.m$p.scores
  d.m <- d.m$d.m

  #create a distance vector to supply to dist.matches function
  order <- switch(order,
                "largest" = order(p.scores[rownames(d.m)], 
                                  decreasing = T),
                "smallest" = order(p.scores[rownames(d.m)]),
                "random" = sample(seq_along(d.m[,1]), nrow(d.m),
                                  replace = FALSE),
                "data" = seq_along(rownames(d.m)))
  
  #get the pairs of matches using the dist.matches function
  pairs <- dist.matches(d.m=d.m, order=order,replace=replace)
  
  #create a dataframe that has all treated units with the matched control
  #units in the same row and the distance between them.
  paired.data <- cbind(distance = dist,
                       t=data[pairs$treatment,],
                       c=data[pairs$control,],
                       pairs) 
  
  paired.data <- paired.data %>% 
                    mutate(d.order=row_number(dist),
                           d.rorder=row_number(-d.order))
  
  matched <- cbind(id = pairs$treatment, 
                   data[pairs$treatment,], 
                   subclass=pairs$treatment, 
                   pair.dist = pairs$dist) %>% 
    rbind(cbind(id = pairs$control,
                data[pairs$control,],
                subclass=pairs$treatment,
                pair.dist = pairs$dist))
  
  matched <- matched %>% arrange(pair.dist, subclass) %>%
    mutate(ord=(row_number(pair.dist) + (row_number(pair.dist)%%2))/2)
  
  #create a dataframe with the id and the number of time the id was used
  #for weighting the matches appropriately
  m.wts <- table(c(pairs$treatment, pairs$control)) %>% as.data.frame()
  
  #get the propensity score, weighting values and stratification
  d.d <- dists(f = f, prop.s = p.scores, data = data)
  
  #add the matched weights to the data
  d.d <- left_join(d.d, m.wts, by = c('idx'='Var1'))
  
  
  return(list(paired.data=paired.data, 
              matched.data=matched,
              data=data,
              distance=dist,
              propensity=d.d$prop.s,
              stratification=d.d$prop.st,
              wt.ATT=d.d$ATT.wt,
              wt.ATE=d.d$ATE.wt,
              wt.Matched=d.d$Freq,
              d.m=d.m,
              pairs=pairs,
              treatment=all.vars(f)[1])
         )
}


```


```{r}
#fev
# d <- mplot::fev
# f <- smoke~age+height
# 
# #lalonde
# # d <- lalonde
# # f <- treat~age+educ
# 
# rep <- T
# ord <- "smallest"
# 
# prop.matches <- matched.data(f=f, data=d, dist="propensity",
#                              order=ord, replace=rep)
# maha.matches <- matched.data(f=f, data=d, dist="mahalanobis",
#                              order=ord, replace=rep)

# lalonde %>% mutate(rn=1:nrow(.), ord=order(-nodegree, rn))

# names(maha.matches$d.m[,1])[1]

# maha.matches$matched.data %>% view()

```

```{r}
accumulate_by <- function(dat, var) {

  var <- lazyeval::f_eval(var, dat)

  lvls <- plotly:::getLevels(var)

  dats <- lapply(seq_along(-lvls), function(x) {

    cbind(dat[var %in% lvls[seq(1, x)], ], frame = lvls[[x]])

  })

  dplyr::bind_rows(dats) %>% mutate(rframe=max(frame)-frame)

}


scatterlines <- function(data, xvar, yvar, facet, full.data, treat){
  
  ggplot(full.data, aes(x=!!sym(xvar), y=!!sym(yvar))) + 
  geom_point(aes(color=factor(!!sym(treat))), shape="X") +
  geom_line(data,aes(group=subclass)) +
  geom_point(data,aes(age, height, color=factor(smoke)))
  
  
  gp <- ggplotly(p) 
  
  gp <- gp %>% 
    animation_opts(transition = 0, redraw=T, frame=120) %>%
    animation_slider(currentvalue = 
                       list(prefix = "Number of obs removed: "))

  return(gp)
}

```



```{r}


```



```{r}
matching.plot <- function(match.data, xvar, yvar, tvar){
  
  mdist <- match.data$distance
  
  all.data <- data.frame(x=match.data$data[[xvar]],
                       y=match.data$data[[yvar]],
                       t=factor(match.data$data[[tvar]]))
  
  
  m.data <- data.frame(
               x=match.data$matched.data[[xvar]],
               y=match.data$matched.data[[yvar]],
               t=factor(match.data$matched.data[[tvar]]),
               subclass=match.data$matched.data[["subclass"]],
               pair.dist=match.data$matched.data[["pair.dist"]]) %>%
    arrange(pair.dist, subclass) %>% 
    mutate(ord=(row_number(pair.dist) + (row_number(pair.dist)%%2))/2)
  
  d.ann <- m.data %>% mutate(distance = mdist, rframe=max(ord)-ord)
  
  d <- accumulate_by(m.data, ~ord) %>% mutate(distance = mdist)
  
  gp <- ggplot(d, aes(x=x, y=y, group=subclass, frame=rframe)) +
    geom_point(aes(color=t), shape=1, 
               alpha=0.5, size=4) +
    geom_line() +
    geom_point(data=d.ann, aes(color=t),
                 size = 5, stroke = 2, shape=21, alpha=0.5) +
    scale_color_manual(values=c(0,1), 
                       palette=colorRampPalette(c("red", "blue"))) 
  
  gp <- ggplotly(gp) %>% 
    add_markers(data=all.data,
                x=~x, y=~y,
                color=~t,
                colors=colorRamp(c("red", "blue")),
                alpha = 0.5,
                type = 'scatter',
                mode = 'markers',
                marker = list(size = 10),
                symbol= ~t,
                symbols = c('105','106'),
                inherit = F) %>% 
    layout(showlegend = FALSE,
           xaxis = list(title=xvar,
                        autorange = TRUE,
                        tickmode="auto"),
           yaxis = list(title=yvar,
                        autorange = TRUE,
                        tickmode="auto")) %>% 
    animation_opts(transition = 0, redraw=T)
  
  return(gp)
}
```



```{r}


# 
# m.title <- "Mahalanobis Distance"
# p.title <- "Propensity Score"
# 
# titles <- list(
#             list(x = 0.25,
#                  y = 1,
#                  font = list(size = 10),
#                  text = m.title,
#                  xref = "paper",
#                  yref = "paper",
#                  xanchor = "center",
#                  yanchor = "bottom",
#                  showarrow = FALSE
#                  ), 
#             list(x = 0.75,
#                  y = 1,
#                  font = list(size = 10),
#                  text = p.title,
#                  xref = "paper",
#                  yref = "paper",
#                  xanchor = "center",
#                  yanchor = "bottom",
#                  showarrow = FALSE
#                  ))
# 
# gg1 <- matching.plot(maha.matches, "age", "height", "smoke", m.title)
# 
# gg2 <- matching.plot(prop.matches, "age", "height", "smoke", p.title)
# 
# subplot(gg1, gg2, shareX = T, shareY = T) %>% 
#   layout(annotations=titles) %>%
#   animation_opts(transition = 0, redraw=T, frame=400) %>%
#   animation_slider(currentvalue = list(prefix = "Number of obs removed: ",
#                                        xanchor = "left",
#                                        font = list(color="black")))

```



```{r}

# m.d <- prop.matches$matched.data
# 
# m.d <- m.d %>% arrange(pair.dist, subclass) %>%
#     mutate(ord=(row_number(pair.dist) + (row_number(pair.dist)%%2))/2)
#   # d.ann <- m.data %>% mutate(distance = mdist, rframe=max(ord)-ord)
#   
# m.d <- accumulate_by(m.d, ~ord) %>% mutate(rframe=max(frame)-frame)

# subset(m.d, rframe=0)

# bals <- lapply(0:(max(m.d$rframe)-2), function(x) 
#           bal.tab(smoke~age+height, data=subset(m.d, rframe==x),
#                   s.d.denom="treated")$Balance)


# bals <- 


std.means <- function(match.data, xvar, yvar, tvar) {
  
  data <- match.data$data
  
  m.data <- match.data$matched.data
  
  m.data <- m.data %>% arrange(pair.dist, subclass) %>%
    mutate(ord=(row_number(pair.dist) + (row_number(pair.dist)%%2))/2)
  
  m.data <- accumulate_by(m.data, ~ord) %>% mutate(rframe=max(frame)-frame)
  
  s.means <- cbind(n = 0:max(m.data$rframe),
        full.smd.x = rep(smd::smd(data[[xvar]], data[[tvar]])$estimate,
                         max(m.data$rframe)+1),
        matched.smd.x = sapply(0:(max(m.data$rframe)), function(x) 
                    smd::smd(subset(m.data, rframe==x)[[xvar]], 
                             subset(m.data, rframe==x)[[tvar]])$estimate),
        full.smd.y = rep(smd::smd(data[[yvar]],data[[tvar]])$estimate,
                         max(m.data$rframe)+1),
        matched.smd.y = sapply(0:max(m.data$rframe), function(x)
                    smd::smd(subset(m.data, rframe==x)[[yvar]],
                             subset(m.data, rframe==x)[[tvar]])$estimate)
  ) %>% as.data.frame()
  
  s.means <- cbind(distance=match.data$distance, s.means)
  # left_join(m.data, s.means)
  
  return(s.means)
    #left_join(m.data, s.means, by=c("rframe"="rframe"), copy=T))

}


hline <- function(y = 0, color = "black") {
    list(
      type = "line",
      x0 = 0,
      x1 = 1,
      xref = "paper",
      y0 = y,
      y1 = y,
      line = list(color = color)
    )
  }

# xvar <- "age"
# yvar <- "height"
# tvar <- "smoke"
# data <- prop.matches$data
# 
# # full.smd.x <- smd::smd(data[[xvar]], data[[tvar]])$estimate
# # full.smd.y <- smd::smd(data[[yvar]], data[[tvar]])$estimate
# # rep(smd::smd(prop.matches$data[[v1]],
# #              prop.matches$data[[vt]])$estimate,
# #     max(m.d$rframe))
# # unlist(lapply(bals, '[[', 2)) %>% matrix(nrow=2) %>% t() 
# 
# s.means.p <- std.means(prop.matches, xvar, yvar, tvar)
# 
# s.means.p.cum <- accumulate_by(s.means.p, ~n) %>% select(-rframe) %>%  mutate(rframe=frame)
# 
# s.means.m <- std.means(maha.matches, xvar, yvar, tvar)
# 
# s.means.m.cum <- s.means.m %>% accumulate_by(~n) %>% select(-rframe) %>%  mutate(rframe=frame)
# 
# s.means.cum <- rbind(s.means.m.cum, s.means.p.cum)
# 
# 
# 
# gg3 <- ggplot(s.means.cum, aes(x=n, frame=rframe)) +
#   geom_line(aes(x=n, y=matched.smd.x, color=distance)) +
#   geom_line(aes(x=n, y=matched.smd.y, color=distance)) 
# 
# gg3 <- ggplotly(gg3) %>%
#   animation_opts(transition = 0, redraw=T, frame=400) %>% 
#     add_lines(data=s.means, x=~n, y=~full.smd.x, inherit = F) %>%
#     add_lines(data=s.means, x=~n, y=~full.smd.y, inherit = F) %>%
#     layout(showlegend = FALSE,
#            xaxis = list(title=xvar,
#                         autorange = TRUE,
#                         tickmode="auto"),
#            yaxis = list(title=yvar,
#                         autorange = TRUE,
#                         tickmode="auto"))

```


```{r}

covar.plot <- function(match.data, xvar, yvar, treatment){
  
  
  
  s.means.p <- std.means(prop.matches, xvar, yvar, tvar)

  s.means.p.cum <- accumulate_by(s.means.p, ~n) %>% select(-rframe) %>%  mutate(rframe=frame)
  
  s.means.m <- std.means(maha.matches, xvar, yvar, tvar)
  
  s.means.m.cum <- s.means.m %>% accumulate_by(~n) %>% select(-rframe) %>%  mutate(rframe=frame)
  
  s.means.cum <- rbind(s.means.m.cum, s.means.p.cum)
  
  
  
  gg3 <- ggplot(s.means.cum, aes(x=n, frame=rframe)) +
    geom_line(aes(x=n, y=matched.smd.x, color=distance)) +
    geom_line(aes(x=n, y=matched.smd.y, color=distance)) 
  
  gg3 <- ggplotly(gg3) %>%
    animation_opts(transition = 0, redraw=T, frame=400) %>% 
      add_lines(data=s.means, x=~n, y=~full.smd.x, inherit = F) %>%
      add_lines(data=s.means, x=~n, y=~full.smd.y, inherit = F) %>%
      layout(showlegend = FALSE,
             xaxis = list(title=xvar,
                          autorange = TRUE,
                          tickmode="auto"),
             yaxis = list(title=yvar,
                          autorange = TRUE,
                          tickmode="auto"))
}

```



```{r}


#vanilla matching
# mod.v.m <- lm(f.t, maha.matches$matched.data)
# matched.m <- cbind(estimate=coef(mod.v.m),confint(mod.v.m))[treatment,]
# 
# mod.v.p <- lm(f.t, prop.matches$matched.data)
# matched.p <- cbind(estimate=coef(mod.v.p),confint(mod.v.p))[treatment,]


get.estimates <- function(match.data, outcome) {
  # fmls <- c(fev~smoke, fev~age+height+sex+smoke)
  treatment <- match.data$treatment
  
  f <- paste0(outcome, " ~ ", match.data$treatment) %>% as.formula()
  d <- match.data$data
  # for (i in fmls) {
  #vanilla
  
  #raw
  mod.v <- lm(f, d)
  raw <- cbind(estimate=coef(mod.v),confint(mod.v))[treatment,]
  
  #weighting
  # ATE.weight <- with(d, smoke/pscore + (1-smoke)/(1-pscore))
  # ATT.weight <- with(d, smoke + (1-smoke)*((1-smoke)/(1-pscore)))
  
  
  mod.w <- lm(f, d, weights = match.data$wt.ATE)
  weighted <- cbind(estimate=coef(mod.w),
                    confint(mod.w))[treatment,]
  #no variable adjustment smoking increases fev by 0.12 (95% CI -0.02 to 0.26)
  #taking into accout age, sex, and ht,
  #smoking decreases fev by -0.21 (95% CI -0.29 to -0.14)
  
  # d$smoke[maha.matches$stratification==1]
  
  max.strat <- max(as.numeric(match.data$stratification))
  
  stratified <- lapply(1:max.strat, function(x) {
         m <- lm(f, d[match.data$stratification==x,])
         
         return(cbind(estimate=coef(m),
                      confint(m))[treatment,])
      }  ) %>% bind_rows() %>% colMeans(na.rm=T)
  
  # d.strat <- d.weighted[!is.na(d.weighted$strat),]
  
  # tmp <- by(d.strat, d.strat$strat, function(x) lm(i, data=x))
  # stratified <- cbind(estimate=apply(sapply(tmp, coef), 1, mean),
  #                     apply(sapply(tmp, confint),1,mean) %>%
  #                       matrix(ncol=2,
  #                              dimnames = list(rownames(confint(tmp[[1]])),
  #                                              colnames(confint(tmp[[1]]))
  #                                              ))
                      # )[treatment,]
  
  a <- rbind(raw, weighted, stratified) %>% as.data.frame()
  
  colnames(a) <- c("estimate", "CI_2.5", "CI_97.5")
  
  a$method <- rownames(a)

  return(a)
  
  }

# }
#no variable adjustment smoking decreases fev by -0.13 (95% CI -0.65 to 0.38)
#taking into accout age, sex, and ht,
#smoking decreases fev by -0.12 (95% CI -0.45 to 0.20)

# ATE.weight[ATE.weight!=ATT.weight]
# ATT.weight[ATE.weight!=ATT.weight]

# ests <- get.estimates(prop.matches, "fev") # %>% as.data.frame()




```



```{r}

#vanilla matching

matching.ests <- function(match.data, outcome){

  f <- paste0(outcome, " ~ ", match.data$treatment) %>% as.formula()


  d <- accumulate_by(match.data$matched.data, ~ord) %>%
            mutate(rframe=max(frame)-frame)
  treatment <- match.data$treatment
  max.match <- max(d$rframe)  
  
  a <- lapply(1:max.match, function(x) {
         m <- lm(f, d[d$rframe==x,])

         return(cbind(distance=match.data$distance,
                      idx=x,
                      estimate=coef(m),
                      confint(m))[treatment,])
      }  ) %>% bind_rows()

  colnames(a) <- c("distance", "idx", "estimate", "CI_2.5", "CI_97.5")
  
  a <- a %>% mutate(across(idx:CI_97.5, as.numeric))
  
  for (x in 1:nrow(a)) {
    if (is.na(a[x,4])) 
      {a[x,4] <- a[x,3]}   
    
    if (is.na(a[x,5])) 
      {a[x,5] <- a[x,3]}
  } 
  
  return(a)

}
  
# comb.match.ests <- rbind(matching.ests(maha.matches, "fev"),
#                          matching.ests(prop.matches, "fev")) 

# lapply()
# mod.v.m <- lm(f.t, maha.matches$matched.data)
# matched.m <- cbind(estimate=coef(mod.v.m),confint(mod.v.m))[treatment,]
# 
# mod.v.p <- lm(f.t, prop.matches$matched.data)
# matched.p <- cbind(estimate=coef(mod.v.p),confint(mod.v.p))[treatment,]


```



```{r}
# xs <- c(0, max(maha.matches$matched.data$ord)) 
# ys <- c(max(ests) + 5, min(ests) - 5) 
# 
# ggplot(data=ests, aes(x=seq(0, xs[2], by=xs[2]/2), y=estimate, color=method)) + geom_hline(yintecept=ests$estimate[1]) #+ ylim(ys) + xlim(xs)

# comb.match.ests <- rbind(matching.ests(maha.matches, "fev"),
#                          matching.ests(prop.matches, "fev")) 
# 
# comb.match.ests.cum <- comb.match.ests %>% accumulate_by(~idx-1) %>%
#                           select(-rframe) %>%  mutate(rframe=frame)
#   
# 
# gg4 <- (ggplot(comb.match.ests.cum, aes(idx, estimate, color=distance, frame=rframe)) + geom_line(size=1) + geom_ribbon(aes(ymin=CI_2.5, ymax=CI_97.5, fill=distance), alpha=0.3)) %>% 
#   ggplotly() 
# %>%
#   animation_opts(transition = 0, redraw=T, frame=400) %>% 
#   # layout(shapes = list(hline(0.05)))
#     # add_lines(data=ests, x=~, y=~full.smd.x, inherit = F) %>%
#     # add_lines(data=s.means, x=~n, y=~full.smd.y, inherit = F) %>%
#     layout(showlegend = FALSE,
#            shapes=list(hline(ests$estimate[1])),
#            # title = paste0(mdist, ' Matching Method'),
#            xaxis = list(title=xvar,
#                         autorange = TRUE,
#                         tickmode="auto"),
#            yaxis = list(title=yvar,
#                         autorange = TRUE,
#                         tickmode="auto"))
# 

```



```{r}

# subplot(gg1, gg2, gg3, gg4, shareX = F, shareY = F, nrows = 2) %>% 
#   layout(annotations=titles) %>%
#   animation_opts(transition = 0, redraw=T, frame=400) %>%
#   animation_slider(currentvalue = list(prefix = "Number of obs removed: ",
#                                        xanchor = "left",
#                                        font = list(color="black")))

```


```{r}

# comb.match.ests[apply(comb.match.ests, 2, is.na)]
# 
# for (x in 1:nrow(comb.match.ests)) {
#   if (is.na(comb.match.ests[x,4])) 
#     {comb.match.ests[x,4] <- comb.match.ests[x,3]}   
#   
#   if (is.na(comb.match.ests[x,5])) 
#     {comb.match.ests[x,5] <- comb.match.ests[x,3]}
#   } 
# 
# ests

```

```{r}


combined.plot <- function(f, d, ord, rep, xvar, yvar, outcome){ 
  
  m.matches <- matched.data(f=f, data=d, dist="mahalanobis",
                             order=ord, replace=rep)
  p.matches <- matched.data(f=f, data=d, dist="propensity",
                             order=ord, replace=rep)
  treatment <- all.vars(f)[1]
  
  
  gg1 <- matching.plot(m.matches, xvar, yvar, treatment)
  
  gg2 <- matching.plot(p.matches, xvar, yvar, treatment)
  
  
  
  s.means.p <- std.means(p.matches, xvar, yvar, treatment)

  s.means.p.cum <- accumulate_by(s.means.p, ~n) %>% 
          select(-rframe) %>%  mutate(rframe=frame)
  
  s.means.m <- std.means(m.matches, xvar, yvar, treatment)
  
  s.means.m.cum <- s.means.m %>% accumulate_by(~n) %>%
          select(-rframe) %>%  mutate(rframe=frame)
  
  s.means.cum <- rbind(s.means.m.cum, s.means.p.cum)
  
  
  gg3 <- ggplot(s.means.cum, aes(x=n, frame=rframe)) +
    geom_line(aes(x=n, y=matched.smd.x, color=distance)) +
    geom_line(aes(x=n, y=matched.smd.y, color=distance)) 
  
  gg3 <- ggplotly(gg3) %>%
    animation_opts(transition = 0, redraw=T, frame=400) %>% 
      add_lines(data=s.means.cum, x=~n, y=~full.smd.x, inherit = F) %>%
      add_lines(data=s.means.cum, x=~n, y=~full.smd.y, inherit = F) %>%
      layout(showlegend = FALSE,
             xaxis = list(title=xvar,
                          autorange = TRUE,
                          tickmode="auto"),
             yaxis = list(title=yvar,
                          autorange = TRUE,
                          tickmode="auto"))
  
  comb.match.ests <- rbind(matching.ests(m.matches, outcome),
                         matching.ests(p.matches, outcome)) 

  comb.match.ests.cum <- comb.match.ests %>% accumulate_by(~idx-1) %>%
                          select(-rframe) %>%  mutate(rframe=frame)
  

  gg4 <- (ggplot(comb.match.ests.cum, 
                 aes(idx, estimate, color=distance, frame=rframe)) +
            geom_line(size=1) + 
            geom_ribbon(aes(ymin=CI_2.5, ymax=CI_97.5, fill=distance),
                        alpha=0.3)) %>%
    ggplotly() 
  
  
  titles <- list(
              list(x = 0.25,
                   y = 1,
                   font = list(size = 10),
                   text = "Mahalanobis Distance Matching",
                   xref = "paper",
                   yref = "paper",
                   xanchor = "center",
                   yanchor = "bottom",
                   showarrow = FALSE
                   ), 
              list(x = 0.75,
                   y = 1,
                   font = list(size = 10),
                   text = "Propensity Score Matching",
                   xref = "paper",
                   yref = "paper",
                   xanchor = "center",
                   yanchor = "bottom",
                   showarrow = FALSE
                   ),
              list(x = 0.25,
                   y = 0.5,
                   font = list(size = 10),
                   text = "Covariate Standardised Mean Difference",
                   xref = "paper",
                   yref = "paper",
                   xanchor = "center",
                   yanchor = "bottom",
                   showarrow = FALSE
                   ),
              list(x = 0.75,
                   y = 0.5,
                   font = list(size = 10),
                   text = "Estimate Treatment Effect",
                   xref = "paper",
                   yref = "paper",
                   xanchor = "center",
                   yanchor = "bottom",
                   showarrow = FALSE
                   ))
  
  
    subplot(gg1, gg2, gg3, gg4, 
            margin = 0.06, shareX = F, shareY = F, nrows = 2) %>% 
      layout(annotations=titles) %>%
      animation_opts(transition = 0, redraw=T, frame=400) %>%
      animation_slider(currentvalue = list(prefix = "Number of obs removed: ",
                                           xanchor = "left",
                                           font = list(color="black")))

  
  }


```


```{r}
# matched.data(f=f, data=d, dist="propensity",
#                               order=ord, replace=rep)

```


```{r}
# d <- create.sim2.data()
d <- create.sim1.data()
f <- t ~ x1 + x2
rep <- F
ord <- "smallest"
xvar <- "x1"
yvar <- "x2"
y <- "y"


combined.plot(f, d, ord, rep, xvar, yvar, y)

  # m.matches <- matched.data(f=f, data=d, dist="mahalanobis",
  #                            order=ord, replace=rep)
  # p.matches <- matched.data(f=f, data=d, dist="propensity",
  #                             order=ord, replace=rep)
  # treatment <- all.vars(f)[1]
  
  
  # gg1 <- matching.plot(m.matches, xvar, yvar, treatment)







```




