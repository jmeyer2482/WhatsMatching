---
title: "R Notebook"
output: html_notebook
---

```{r}

library(tidyverse)
library(MatchIt)
library(cem)
library(ggpubr)
library(cobalt)

#########################################################################
###############function to create data set 2
cd1 <- function() {
    
    x1 <- c(runif(100, 0,5),runif(100, 1,6))
    x2 <- c(runif(100, 0,5),runif(100, 1,6))
    x3 <- rep(c(rep("A",25), rep("B",25),rep("C",25), rep("D",25)),2)
    t <- c(rep("C",100),rep("T",100))
    y <- 2*ifelse(t=="C",0,1) + x1 + x2 #+ rnorm(200)

    d <- list(x1=x1,x2=x2,x3=x3,t=t,y=y) %>% as.data.frame()

    return(d)
}


dists <- function(data, form.t=NULL, model.t=NULL, form.y=NULL, model.y=NULL) {
    
    #get the response variable from the formula
    t = all.vars(form.t)[1]
    
    #check the response is binary for logistic regression
    if(all(as.numeric(data[t] == data[1,t]) %in% c(0,1))) {
        data[t] <- as.numeric(data[t] != data[1,t])
    }
    
    #calculate the propensity score using logistic regression
    if (is.null(model.t)){
        prop.s <- glm(form.t, data=data, family = "binomial") %>% fitted()
    }
    
    
    
    dt <- cbind(idx= str_pad(row.names(data), nchar(nrow(data)), pad = "0"), data, prop.s)
    
    dt <- dt %>% mutate(prop.wt=ifelse(t==1, 1/prop.s,1/(1-prop.s)))
    
    Q <- quantile(dt$prop.s, prob=seq(from=0,to=1,by=0.2),na.rm=TRUE)
    dt$prop.st <- cut(dt$prop.s, breaks = Q, labels = 1:5, include.lowest = TRUE)
    
    return(dt)
}

d1 <- dists(form.t=t ~ x1 + x2, data=cd1())


# a <- glm(t ~ x1 + x2, data=d1, family = "binomial") 
# m1 <- glm(ifelse(t=="C",0,1)~x1+x3, data=d1)
# a$model
# 
# all.vars(a$terms)
# 
# lm(y~t, data = d1)
# lm(y~t, weights = d1$prop.w, data = d1)
# 
# 
# summary(d1$prop.s)
# 
# typeof(a)

# a %>% predict(newdata=d1, type = "response") == a$fitted.values


```


```{r}
f1 <- y ~ x2 * x1 * I(x1*x2) * I(x1^2) * I(x2^2) * I(x1^2*x2) * I(x1*x2^2) * I(x1^3) * I(x2^3)

output <- NULL


f1.t <- paste(f1[[2]],f1[[1]],"t",c("",paste("+",labels(terms(f1)))))

# f1.t <- "y ~ t + x1 + x2"

# f1.t <- str_replace_all(f1.t, ":", "+")


f1.l <- lapply(f1.t,function(x) lm(x, data=d1))

# f1.s <- sapply(f1.t,function(x) lm(x, data=d1, weights= d1$prop.wt))

f1.est <- sapply(1:length(f1.l), function(x) f1.l[[c(x,1,2)]])

output <- rbind(output, cbind(mod="Vanilla",var=var(f1.est),max=max(f1.est), av=mean(f1.est)))

plot(f1.est, type = "l")

# [1] 0.03991049
# [1] 4.200924

f1.l <- lapply(f1.t,function(x) lm(x, data=d1, weights= d1$prop.wt))

# f1.s <- sapply(f1.t,function(x) lm(x, data=d1, weights= d1$prop.wt))

f1.est <- sapply(1:length(f1.l), function(x) f1.l[[c(x,1,2)]])



# var(f1.est)  #[[1]][2]
# max(f1.est)  #[[1]][2]

output <- rbind(output, cbind("Weighted",var(f1.est), max(f1.est), 
                              av=mean(f1.est)))
plot(f1.est, type = "l")
# [1] 0.005683825
# [1] 2.525635

v <- NULL

for (i in 1:5){
    


f1.l <- lapply(f1.t,function(x) lm(x, data=d1[d1$prop.st==i,] ))

# f1.s <- sapply(f1.t,function(x) lm(x, data=d1, weights= d1$prop.wt))

# f1.l[[98]]

f1.est <- sapply(1:length(f1.l), function(x) f1.l[[c(x,1,2)]])

v <- rbind(v,cbind(variance=var(f1.est), max=max(f1.est), av=mean(f1.est)))

}

output <- rbind(output, cbind("Stratified",apply(v, 2, mean)%>%t())) %>%
    as.data.frame()
# d1 %>% select(prop.st, t) %>% group_by_all() %>% mutate(n=n()) %>% unique()
plot(f1.est, type = "l")

```



```{r}

df1 <- full_join(d1,d1,by=character(),suffix = c("", ".y")) %>% filter(t != t.y) %>% mutate(p.dist=abs(prop.s - prop.s.y))


p.matches <- NULL
# m.matches <- NULL
p.ids <- list(idx=NULL,idx.y=NULL)
# m.ids <- list(id=NULL,s_id=NULL)

for (i in 1:(nrow(df1))) {
    
    if (nrow(df1 %>% filter(!idx.y %in% p.ids$idx.y, !idx %in% p.ids$idx))!=0) {
    
    p <- df1 %>% filter(!idx.y %in% p.ids$idx.y, !idx %in% p.ids$idx) %>% 
          filter(p.dist == min(p.dist)) 
    p.matches <- rbind(p.matches, p)
    p.ids <- p.matches[c("idx", "idx.y")]
    
    # m <- df3 %>% filter(!s_id %in% m.ids$s_id, !id %in% m.ids$id) %>% 
    #       filter(m.dist == min(m.dist)) 
    # m.matches <- rbind(m.matches, m)
    # m.ids <- m.matches[c("id", "s_id")]
    }
    
}


dm <- as.matrix(p.matches[,c('x1','x2')]-p.matches[,c('x1.y','x2.y')])

#covariance matrix
c <- cov(d1[,c('x1','x2')])

# solve  (covariance matrix) %*% x = d for x
cov.d <- sapply(1:nrow(p.matches), function(x) solve(c,dm[x,])) %>% t()

# Mahalanobis calculation forced in two steps
p.matches$m.dist <- apply(dm*cov.d, 1, sum)


p.matches %>% rowwise() %>% 
    mutate(a=x1-x1.y, b=x2-x2.y,
           m.d = sum(c(a,b)*solve(cov(d1[,c('x1','x2')]), c(a,b)))) %>% select(-a, -b)


```



```{r}

# join(d1,p.matches,"")

ests <- NULL
b <- NULL

for (i in seq(1,(nrow(p.matches)-9),by=2)){
    
    data <- p.matches %>% arrange(desc(p.dist),t) %>% .[i:nrow(p.matches),]
    
    bals <- bal.tab(t ~ x1 + x2, data = data, 
                    distance = "prop.s", s.d.denom = "treated")

    b <- rbind(b,list(x1.bal = bals$Balance[2,2], x2.bal = bals$Balance[1,2]) %>% 
                   as.data.frame())
    
    f1.l <- lapply(f1.t,function(x) lm(x, data=data))
    
    # f1.s <- sapply(f1.t,function(x) lm(x, data=d1, weights= d1$prop.wt))
    
    # f1.l[[98]]
    
    f1.est <- sapply(1:length(f1.l), function(x) f1.l[[c(x,1,2)]])
    
    ests <- rbind(ests,cbind(n=i,variance=var(f1.est), max=max(f1.est), av=mean(f1.est)))

}

ests <- ests %>% as.data.frame()
output <- output %>% as.data.frame()

colnames(output)<- c("model", "vars", "max.val", "av")

output$vars <- output$vars %>% as.numeric()

output$max.val <- output$max.val %>% as.numeric()

```


```{r}
ggplot(p.matches, aes(x1,x2, color = as.factor(t))) + 
  annotate("rect", xmin=0, xmax=5, ymin=0, ymax=5, alpha=0.1, fill="blue") + 
  annotate("rect", xmin=1, xmax=6, ymin=1, ymax=6, alpha=0.1, fill="red") +
  scale_color_manual(values=c("blue", "red"), name="Group", labels = c("Control","Treat")) +
  geom_segment(data=p.matches[p.matches$t==0,],
               aes(x=x1,xend=x1.y,y=x2,yend=x2.y, 
                   alpha=cut(rank(p.dist),4,
                             labels=c(1,2,3,4))), 
               color= "black", arrow = arrow(length = unit(0.2,"cm"))) +
    scale_alpha_discrete(name="Cuts", labels=c("1st", "2nd", "3rd", "4th"), range = c(1,0.1)) +
  geom_point() + theme_classic() 


ggplot(p.matches[p.matches$t==0,], aes(prop.s,prop.s.y, color=p.dist)) + 
  geom_abline(slope=1) + geom_point() + theme_classic() + lims(x=c(0,1),y=c(0,1)) 

ggplot(p.matches[p.matches$t==0,], aes(prop.s,prop.wt, color=prop.st)) + 
 geom_point(alpha=0.7) + theme_classic()# + lims(x=c(0,1),y=c(0,1)) 

ggplot(p.matches[p.matches$t==0,], aes(p.dist, m.dist, color=prop.st)) + 
 geom_point(alpha=0.7) + theme_classic()# + lims(x=c(0,1),y=c(0,1)) 

ggplot(p.matches[p.matches$t==0,], aes(prop.s,m.dist, color=prop.st)) + 
 geom_point(alpha=0.7) + theme_classic()# + lims(x=c(0,1),y=c(0,1)) 

```




```{r}

ggarrange(
ggplot(ests, aes(n, variance)) + geom_line() + 
    geom_hline(data = output, aes(yintercept=vars, color=model)) +
    labs(x="Number of units removed", y="Average estimate variance"),

ggplot(ests, aes(n, max)) + geom_line() + 
    geom_hline(data = output, aes(yintercept=max.val, color=model)) +
    labs(x="Number of units removed", y="Maximum estimate"),

ggplot(ests, aes(n, av)) + geom_line() + 
    geom_hline(data = output, aes(yintercept=as.numeric(av), color=model)) + 
    labs(x="Number of units removed", y="Average estimate"),
common.legend = T, legend = "bottom"
) %>% annotate_figure(top = "Output for 512 models including second and third order interactions")

```


```{r}

# covs <- subset(p.matches, select = c(x1, x2, t))
# 
# bal.tab(covs, treat = p.matches$t)
# bal.tab(covs, treat = p.matches$t, weights = p.matches$prop.wt)

# bals <- bal.tab(t ~ x1 + x2, data = p.matches, distance = "prop.s", s.d.denom = "treated")

# bals$Balance[c(2:nrow(bals$Balance)),2]

bal.wt <- bal.tab(t ~ x1 + x2, data = p.matches, weights = "prop.wt",
        distance = "prop.s", s.d.denom = "treated", unbal=T)$Balance

#            Type Diff.Adj
# prop.s Distance   0.0691
# x1      Contin.   0.0529
# x2      Contin.   0.0932


bal.strat <- bal.tab(t ~ x1 + x2, data = p.matches, subclass = "prop.st",
        distance = "prop.s", s.d.denom = "treated", 
        which.subclass = .all, subclass.summary = TRUE)$Balance

```





```{r}

ggarrange(
ggplot(b, aes(x=row(b)[,1])) + geom_line(aes(y=x1.bal, color="Matched")) +
    geom_hline(aes(yintercept=bal.wt[2,3], color="Weighted"), ) +
    geom_hline(aes(yintercept=bal.strat[2,3], color="Stratified")) +
    theme_classic() + theme(legend.position = "right") +
    geom_ribbon(aes(ymin=-0.1,ymax=0.1), alpha=0.2) +
    scale_color_manual(values = c("black", "darkblue", "blue"), 
                       name = "Method") + labs(title="x1",x="",y=""),
ggplot(b, aes(x=row(b)[,1])) + geom_line(aes(y=x2.bal, color="x2 Match")) + 
    geom_hline(aes(yintercept=bal.wt[3,3], color="x2 Wt")) +
    geom_hline(aes(yintercept=bal.strat[3,3], color="x2 Strat")) +
    geom_ribbon(aes(ymin=-0.1,ymax=0.1), alpha=0.2) +
    theme_classic() + theme(legend.position = "right") +
    scale_color_manual(values = c("black", "blue", "darkred"), 
                       name = "Covariate") + labs(title="x2",x="",y=""),
common.legend = T, legend = "top"

) %>% annotate_figure(top = "Covariate balance by difference in standarised means", 
                      left = "Standardised mean difference",
                      bottom = "Number of pairs removed")
```


```{r}
# for (i in 1:200) {
# sapply(200, function(x) for(i in 1:x) {mean(rnorm(200))})
# }
```



```{r}
distance <- fitted(glm(treat~age+educ,lalonde, family="binomial"))

sprobs <- seq(0, 1, length.out = round(6) + 1)

quantile(distance[lalonde$treat==1], probs = sprobs, na.rm = TRUE)

```


```{r}
match <- matchit(treat~age+educ, lalonde, distance = "mahalanobis" , replace = T, m.order = "largest")
# summary(match)

match.out <- match.data(match)
# summary(match.out)

# ggplot(match.out, aes(educ, age)) + geom_point(aes(color = as.factor(treat))) + geom_line(aes(group=subclass))

d.matrix <- optmatch::match_on(distance, z=lalonde$treat)
d.matrix <- optmatch::match_on(match$formula, data = lalonde, method = "mahalanobis")

mat <-  dist.matches(d.matrix, replace = T, order = "largest")


# match$match.matrix==as.matrix(mat[['control']])

cbind(mat, matchit = match$match.matrix) %>% filter(control!=matchit)


```


