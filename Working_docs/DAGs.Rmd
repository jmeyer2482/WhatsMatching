---
title: "DAGs"
output: html_notebook
---


```{r}

dag.sim.new  <- function (dag, b = rep(0, nrow(dag$arc)), bxy = 0, n=200, 
                          mu = rep(0, length(dag$x)),
                      distrib = rep(0, length(dag$x)),
                       stdev = rep(0, length(dag$x)), seed = NA) 
{

  # arguments:
  #
  # b  - the regression coefficient (on linear scale)
  # mu - for continuous variables, the overall mean simulated
  #      for binary variables, proportion of successes simulated
  # stdev - for continuous variables without ancestors, the sd of the simulated distribution
  #         for other variables, the sd of the noise added to the calculated value
  #         (might not be very reasonable for binary variables, where it just biases towards 0,
  #          i.e. reducing the b should do the same; for continuous, it broadens the conf.int.)
  #         Note. the noise is added after shifting to the mean, so the mean will not be exact.
  #         Note. the noise is added before calculating descendant nodes, i.e. it is sort of
  #               true inter-individual variation, not measurement error.
  #         Note. doubles as range for uniform distribution
  # distrib - 1 for binary nodes, 0 for continuous nodes, 2 for uniform
  #         Note. the nodes are made binary before calculating descendant nodes, i.e. there
  #               will be a discrete difference--not a continuous change--in the descendants.


  logit<-function(p) log(p/(1-p));            # helper function;
  inv.logit<-function(l) exp(l)/(1+exp(l));   # helper function;

  if (length(b) != nrow(dag$arc)) {
      stop("number of coefficients does not fit number of arcs");
  }
      
  writeLines("Note: undirected arcs are discarded, an xy arc is appended.");
  dag$arc <- dag$arc[dag$arc.type == 0, ]; # discard undirected arcs;
  nodes <- length(dag$x);
  dag$arc <- rbind(dag$arc, c(1, nodes))   # append xy arc (node 1 -> last node);
    
  b <- b[dag$arc.type == 0];               # discard b's belonging to undirected arcs;
  b <- c(b, bxy);                          # append bxy to b's;
  
  # following two lines just so that the internal dag remains consistent in itself...
  dag$arc.type <- dag$arc.type[dag$arc.type == 0];  # discard arc.type of undirected arcs;
  dag$arc.type <- c(dag$arc.type, 0);               # append arc.type for xy arc;
    
   
  df <- data.frame(matrix(ncol = nodes, nrow = n)); # prepare data.frame to simulate;
  if(!is.na(seed)) set.seed(seed);
  all.simulated <- FALSE;
  counter <- 1;
  
  while (all.simulated == FALSE) {
    for (i in 1:nodes) {
      if (is.na(df[1, i])) {
        if (length(dag.ancestors(dag, A = i)) == 1) {   # does node have no ancestor?;
          if (distrib[i]==0) {
            df[, i] <- rnorm(n, mean=mu[i], sd=stdev[i]);  # simulate continuous node with no ancestors;
          } else
          if (distrib[i]==1) {
            df[, i] <- rbinom(n=n, size=1, prob=mu[i]); # simulate binary node with no ancestors;
          } else
          if (distrib[i]==2) {
            df[, i] <- runif(n=n, min=mu[i]-stdev[i]/2, max=mu[i]+stdev[i]/2); # simulate uniform node with no ancestors;
          }
        }
        else {
          if (all(!is.na(df[1, dag.ancestors(dag, i)[-1]]))) { # are all ancestors already simulated?;
            relevant.b <- b[which(dag$arc[, 2] == i)]; # reduce b's to those of arcs pointing to node i;
            relevant.x <- as.matrix(cbind(df[, dag$arc[dag$arc[,2] == i, 1]], rep(0, n)));
                                                       # reduce simulated nodes to ancestors of i;
            
            pred.value <- rowSums(relevant.x %*% c(relevant.b, 0)); # calculate new node "predicted value";
            noise2add  <- rnorm(mean=0, sd=stdev[i], n=n);             # noise to add;
            
            if(distrib[i]==0) {
              raw.value <- pred.value + (mu[i]-mean(pred.value)) + noise2add; # shift and add noise!!!;
              df[, i]   <- raw.value;                                         # assign to data.frame;
            } else
            if(distrib[i]==1) {
              raw.value <- pred.value + (logit(mu[i])-mean(pred.value)) + noise2add;             # shift and add noise!!!;
              df[, i]   <- sapply(raw.value, FUN = function(x)
                                                   {rbinom(n = 1, size = 1, prob = inv.logit(x))}); # assign binary to data.frame;
            } else
            if(distrib[i]==2) {
              noise2add  <- rnorm(mean=0, sd=(0.28*stdev[i]), n=n);
              raw.value <- pred.value + (mu[i]-mean(pred.value)) + noise2add;             # shift and add noise!!!;
              df[, i]   <- raw.value; # assign to data.frame;
            }
          } #simulate ancestors
        } #ancestors?
      }#data?
    } #nodes
    counter <- counter + 1; # not really used for anything...;
    all.simulated <- all(!is.na(df[1, ])); # are all nodes already simulated?;
  
  } #while all.simulated
  
  names(df)<-dag$symbols; # for now, it's either X1,X2,... or the "symbols";
    
  rv <- df
  return(rv)
}
```



```{r}
## Simulate data with pre-defined path coefficients of -.6
g <- dagitty('dag{z -> x [beta=-.6] x <- y [beta=-.6] }')
x <- simulateSEM( getExample("confounding") ) 
cov(x)

getExample("confounding")



rbeta(200,-0.6,-0.6)


# d1 <- 'dag { bb="-2.923,-6.036,4.208,8.104" T [exposure,pos="-2.027,0.247"] Y [outcome,pos="3.538,0.549"] x1 [pos="-1.019,-3.500"] x2 [pos="0.602,-3.500"] x3 [pos="2.153,-3.500"] x4 [pos="-0.410,3.500"] x5 [pos="1.776,3.500"] T -> Y T -> x1 T -> x2 T -> x4 Y -> x4 x1 -> Y x2 -> x3 x3 -> Y x5 -> T x5 -> Y }'

d1 <- 'dag { T [exposure, pos="-3.514,0"] Y [outcome, pos="3.514,0"] T -> Y T -> x1 T -> x2 T -> x4 Y -> x4 x1 -> Y x2 -> x3 x3 -> Y x5 -> T x5 -> Y }' %>% dagitty()

paths(d1)
simulateSEM(d1, standardized = F)

dag1 <- dagitty(d1)
plot(d1)

d1

dagR::
dagR::dag.sim(dag1)

dag.draw(demo.dag0())

library(dagR)
```


```{r}
c.names <- c("x1", "x2", "x3", "x4", "x5")
c.vals <- rep(1,length(c.names))
#7 vars. 1 and 7 are t and y. x1-x5 are 2-6.
arcs <- c(0,1, 0,2, 0,4, 1,-1 ,2,3 ,3,-1, 5,0, 5,-1) 

DAG <- dag.init(covs = c.vals, cov.names = c.names, x.name = "t", y.name = "y", arcs = arcs, symbols = c("t", c.names, "y"))

# dag.draw(DAG,legend = F, noxy=2)

coefs <- rnorm(n=length(arcs)/2, sd=5)
means <- c(0.5,  10,  7,   6,  5,  3,  0)
sdevs <- c(  0, 1.3, 12, 2.6, 25, .9,  1)
bin <- c(1,0,0,0,2,0,0)

# sim.d <- dag.sim(DAG, n=200, bxy=2, b=coefs, binary = bin, mu=means,
#         seed=10, stdev = sdevs)

# dagR::plot.dagRdag(DAG)

DAGity <- dagR2dagitty(DAG) %>% as.dagitty()

# library(dagitty)
xs <- seq(3,7,along.with=c.names)
ys <- rep(c(3,7), length(xs))[1:length(xs)]

x <- c(1, xs, 9)
y <- c(5, ys, 5)
names(x) <- c("t", c.names, "y")
names(y) <- c("t", c.names, "y")


coordinates(DAGity) <- list(x=x, y=y)

# plot(dagitty::graphLayout(DAGity))

# plot(dagitty(DAGity, layout=T))

plot(DAGity)

DAG$arc
DAG

n.data <- dag.sim.new(DAG, n=200, bxy=2, b=coefs, distrib = bin, mu=means,
         seed=10, stdev = sdevs)

```

```{r}

ggplot(n.data, aes(shape=factor(t), color=y)) + geom_point(aes(x1,x2)) + viridis::scale_color_viridis()

ggplot(n.data, aes(shape=factor(t), color=y)) + geom_point(aes(x1,x3)) + viridis::scale_color_viridis()

ggplot(n.data, aes(shape=factor(t), color=y)) + geom_point(aes(x1,x4)) + viridis::scale_color_viridis()


ggplot(n.data, aes(shape=factor(t), color=y)) + geom_point(aes(x1,x5)) + viridis::scale_color_viridis()


# mean(c(34,40))

# table(sim.d$t)

hist(n.data$x4)

ggplot(n.data, aes(t,y)) + geom_col()


sd(runif(200, 36,155))

0.28*(155-36)



```

```{r}
lm(y ~ x1 + x2 + x3 + x4 + x5 + t , n.data) %>% summary()
cbind(DAG$arc,coefs)



```


```{r}

c.names <- c("x1", "x2")
c.vals <- rep(1,length(c.names))
#7 vars. 1 and 7 are t and y. x1-x5 are 2-6.
arcs <- c(0,1, 0,2, 1,-1, 2,-1) 

DAG <- dag.init(covs = c.vals, cov.names = c.names, x.name = "t", y.name = "y", arcs = arcs, symbols = c("t", c.names, "y"))

# dag.draw(DAG,legend = F, noxy=2)

coefs <- c(1, 1, 2, 2)
means <- c(0.5,  2.5, 2.5, 5.5)
sdevs <- c(  0, 5, 5, 0.28*5)
bin <- c(1,2,2,0)

# sim.d <- dag.sim(DAG, n=200, bxy=2, b=coefs, binary = bin, mu=means,
#         seed=10, stdev = sdevs)

# dagR::plot.dagRdag(DAG)

DAGity <- dagR2dagitty(DAG) %>% as.dagitty()

# library(dagitty)
xs <- seq(3,7,along.with=c.names)
ys <- rep(c(3,7), length(xs))[1:length(xs)]

x <- c(1, xs, 9)
y <- c(5, ys, 5)
names(x) <- c("t", c.names, "y")
names(y) <- c("t", c.names, "y")


coordinates(DAGity) <- list(x=x, y=y)

# plot(dagitty::graphLayout(DAGity))

# plot(dagitty(DAGity, layout=T))

plot(DAGity)

DAG$arc
DAG

n.data <- dag.sim.new(DAG, n=200, bxy=2, b=coefs, distrib = bin, mu=means,
         seed=10, stdev = sdevs)


n.data %>% ggplot(aes(x1,x2, color=t)) + geom_point()


library(ggdag)



```
